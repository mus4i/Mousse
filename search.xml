<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>“集合类的使用”</title>
      <link href="/2023/10/22/%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/10/22/%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Collection类的一些常用方法"><a href="#Collection类的一些常用方法" class="headerlink" title="Collection类的一些常用方法"></a>Collection类的一些常用方法</h2><pre><code>&#39;&#39;&#39;        Collection&lt;String&gt; coll = new ArrayList&lt;&gt;();        coll.add(&quot;呵呵哒&quot;);        coll.clear(); //清空该集合所有元素        coll.isEmpty();//判断是否是空集合        coll.size();//获取集合大小        coll.contains(&quot;呵呵哒&quot;);//判断集合是否包含某个指定元素        coll.remove(&quot;呵呵哒&quot;);//删除集合某个指定元素        coll.toArray(); //把集合转换成数组。&#39;&#39;&#39;</code></pre><h2 id="iterator类迭代器的使用"><a href="#iterator类迭代器的使用" class="headerlink" title="iterator类迭代器的使用"></a>iterator类迭代器的使用</h2><pre><code>&#39;&#39;&#39;        Collection&lt;String&gt; coll2 = new ArrayList&lt;&gt;();        coll2.add(&quot;呵呵哒&quot;);        coll2.add(&quot;呵呵哒&quot;);        coll2.add(&quot;呵呵哒&quot;);        coll2.add(&quot;呵呵哒&quot;);        coll2.add(&quot;呵呵哒&quot;);        coll.addAll(coll2);        Iterator&lt;String&gt; iterator = coll.iterator();        while (iterator.hasNext())&#123; //判断当前指向元素是否存在            System.out.println(iterator.next());   //输出当前指向元素        &#125;&#39;&#39;&#39;</code></pre><h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><p>   增强for循环遍历集合， 就是迭代器遍历集合的简化写法</p><pre><code>&#39;&#39;&#39;        for(String str : coll)&#123;  //增强for循环， 用以遍历数组或集合 格式为：for(数据类型 变量名 : 需要遍历的数组或集合) 其中， 变量名为被遍历的其中每一个元素            System.out.println(str);        &#125;        int [] arr = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;;           for (int i : arr)&#123;          //增强for循环遍历数组   快捷键： arr.for            System.out.println(i);        &#125;&#39;&#39;&#39;</code></pre><h3 id="集合的forEach方法，-用lambda表达式实现集合的遍历"><a href="#集合的forEach方法，-用lambda表达式实现集合的遍历" class="headerlink" title="集合的forEach方法， 用lambda表达式实现集合的遍历"></a>集合的forEach方法， 用lambda表达式实现集合的遍历</h3><pre><code>&#39;&#39;&#39;        coll.forEach(new Consumer&lt;String&gt;() &#123;  //coll是集合， 上面代码的集合            @Override            public void accept(String s) &#123;    //匿名内部类实现                System.out.println(s);            &#125;        &#125;);        coll.forEach(s -&gt; System.out.println(s));  //一部部简化        coll.forEach(System.out::println);   //最终简化版本&#39;&#39;&#39;</code></pre><h3 id="List类集合的使用"><a href="#List类集合的使用" class="headerlink" title="List类集合的使用"></a>List类集合的使用</h3><pre><code>&#39;&#39;&#39;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(0, &quot;呵呵哒&quot;);  //在指定位置插入指定元素， 可以和插入队伍        list.remove(0);  //删除指定索引位置的元素, 并返回被删除的元素        list.add(&quot;呵呵哒&quot;);        list.add(&quot;呵呵哒&quot;);        list.add(&quot;呵呵哒&quot;);        list.add(&quot;呵呵哒&quot;);        list.set(0, &quot;呵呵哒&quot;);  //修改指定索引位置的元素， 并返回被修改的值        list.get(0); //返回指定索引位置的元素&#39;&#39;&#39;</code></pre><h3 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h3><pre><code>&#39;&#39;&#39;        //创建队列！    LinkedList&lt;String&gt; link = new LinkedList();    link.addLast(&quot;呵呵哒1&quot;);  //在末位置增加元素    link.addLast(&quot;呵呵哒2&quot;);    link.addLast(&quot;呵呵哒3&quot;);    link.addLast(&quot;呵呵哒4&quot;);    link.addLast(&quot;呵呵哒5&quot;);    System.out.println(link);    link.removeFirst();     //删除头部元素    link.removeFirst();    System.out.println(link);    link.removeLast();     //删除尾部元素    link.removeLast();    System.out.println(link);    //        for (String s : link) &#123;    //            System.out.println(s);    //        &#125;    //创建栈！    LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();    list.addFirst(&quot;呵呵哒1&quot;);   //从头部增加元素    list.addFirst(&quot;呵呵哒2&quot;);    list.push(&quot;呵呵哒3&quot;);    list.push(&quot;呵呵哒4&quot;);   //push方法和addfirst是一样的    list.push(&quot;呵呵哒5&quot;);    System.out.println(list);    //出栈    list.removeFirst();    list.removeFirst();    list.pop();    list.pop();   //pop方法和removefirst是一样的    System.out.println(list);&#39;&#39;&#39;</code></pre><h3 id="Set类的三个子类"><a href="#Set类的三个子类" class="headerlink" title="Set类的三个子类"></a>Set类的三个子类</h3><p>   其中， linkedhashset类是hashset类的子类</p><pre><code>&#39;&#39;&#39;    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();   //无序， 不重复， 无索引    set.add(111);    set.add(222);    set.add(333);    set.add(444);    set.add(444);    set.add(444);    set.add(444);    System.out.println(set);    Set&lt;Integer&gt; setlink = new LinkedHashSet&lt;&gt;();  //有序， 不重复， 无索引    setlink.add(111);    setlink.add(222);    setlink.add(333);    setlink.add(444);    setlink.add(444);    setlink.add(444);    setlink.add(444);    System.out.println(setlink);    Set&lt;Integer&gt; treesets = new TreeSet&lt;&gt;();    //默认有序， 不重复， 无索引    treesets.add(444);    treesets.add(222);    treesets.add(1111);    treesets.add(777);    treesets.add(777);    System.out.println(treesets);&#39;&#39;&#39;</code></pre><h2 id="MAP集合"><a href="#MAP集合" class="headerlink" title="MAP集合"></a>MAP集合</h2><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><pre><code>&#39;&#39;&#39;        maptest.put(1, &quot;呵呵哒&quot;);        maptest.put(2, &quot;呵呵哒&quot;);        maptest.put(3, &quot;呵呵哒&quot;);        maptest.put(4, &quot;呵呵哒&quot;);        maptest.put(8, &quot;呵呵哒&quot;);        maptest.put(null, null);        System.out.println(maptest);        System.out.println(maptest.size());  //获取集合的大小        maptest.clear();   //清空集合        maptest.isEmpty();  //判断集合是否为空        maptest.get(2);  //通过键值获取对应值        maptest.put(1, &quot;呵呵哒&quot;);        maptest.put(2, &quot;呵呵哒&quot;);        maptest.put(3, &quot;呵呵哒&quot;);        maptest.put(4, &quot;呵呵哒&quot;);        maptest.put(8, &quot;呵呵哒&quot;);        maptest.put(null, null);        maptest.remove(2);  //通过键值删除对应元素        maptest.containsKey(2);//判断是否包含某个键        maptest.containsValue(&quot;呵呵哒&quot;);//判断是否包含某个值        maptest.keySet();  //获取集合的全部键        maptest.values();  //获取集合的全部值        Map&lt;Integer, String&gt; maptest2 = new HashMap&lt;&gt;();        maptest2.putAll(maptest);//把map1的键全部倒入map2中, 重复的键会覆盖        System.out.println(maptest2);&#39;&#39;&#39;</code></pre><h4 id="map集合遍历方式"><a href="#map集合遍历方式" class="headerlink" title="map集合遍历方式"></a>map集合遍历方式</h4><p>‘’’</p><pre><code>    //遍历map集合    //1. 通过键找值    Set&lt;Integer&gt; integers = maptest.keySet();    for (Integer integer : integers) &#123;        String s = maptest.get(integer);        System.out.println(integer + &quot;-&quot; + s);    &#125;    //2. 通过entrySet方法遍历    Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entries = maptest.entrySet();    for (Map.Entry&lt;Integer, String&gt; entry : entries) &#123;        System.out.println(entry.getKey() +&quot;-&quot;+ entry.getValue() +&quot; &quot;);    &#125;    //3. 用lambda表达式遍历    maptest.forEach((k, v) -&gt; &#123;        System.out.println(k+&quot;-&quot;+v);    &#125;);</code></pre><p>‘’’</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>单例设计模式</title>
      <link href="/2023/10/14/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/10/14/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="单例设计模式创建的方法"><a href="#单例设计模式创建的方法" class="headerlink" title="单例设计模式创建的方法"></a>单例设计模式创建的方法</h1><ol><li><p>饿汉式单例： 拿对象时， 对象已经建立完成。</p><p> ‘’’java</p><pre><code> //2.定义一个类变量， 记住类的对象 private static A a = new A(); //1.私有构造器 private A()&#123; &#125; //3.定义一个类方法， 返回类的对象 public static A getA()&#123;     return a; &#125;</code></pre><p> ‘’’</p></li><li><p>懒汉式单例， 拿对象时， 才开始创建对象。<br> ‘’’java</p><pre><code> //2. 定义一个类变量， 用于存储对象 private static B b; //1. 把构造器私有 private B()&#123; &#125; //3. 定义一个方法， 只有在调用时才创建对象 public static B getInstance()&#123;     if (b == null)&#123;         b = new B();     &#125;     return b; &#125;</code></pre><p> ‘’’</p></li></ol><p>用这种模式创建的对象有且仅有一个</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>API常用类</title>
      <link href="/2023/10/07/API%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
      <url>/2023/10/07/API%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="char字符数组转换成String的一种方式"><a href="#char字符数组转换成String的一种方式" class="headerlink" title="char字符数组转换成String的一种方式"></a>char字符数组转换成String的一种方式</h2><pre><code>    &#39;&#39;&#39;java        char [] arr = new char[]&#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;;        String str = new String(arr);        System.out.println(str);    &#39;&#39;&#39;</code></pre><h2 id="String类常用的方法："><a href="#String类常用的方法：" class="headerlink" title="String类常用的方法："></a>String类常用的方法：</h2><ol><li><p>public int length()            获取字符串的长度返回(就是字符个数</p><pre><code> &#39;&#39;&#39;java     System.out.println(str.length()); &#39;&#39;&#39;</code></pre></li><li><p>public char charAt(int index)        获取某个索引位置处的字符返回   </p><pre><code> &#39;&#39;&#39;java     for (int i = 0; i &lt; str.length(); i++) &#123;                 char ch = str.charAt(i);                 System.out.println(ch);             &#125; &#39;&#39;&#39;</code></pre></li><li><p>public char[] toCharArray():         将当前字符串转换成字符数组返回</p><pre><code> &#39;&#39;&#39;java     char[] chars = str.toCharArray(); &#39;&#39;&#39;</code></pre></li><li><p>public boolean equals(Object anObject)   判断当前字符串与另一个字符串的内容一样，一样返回true</p><pre><code> &#39;&#39;&#39;java     System.out.println(str.equals(str2)); &#39;&#39;&#39;</code></pre></li><li><p>public boolean equalsIgnoreCase(String anotherString)   判断当前字符串与另一个字符串的内容是否一样(忽略大小写)</p><pre><code> &#39;&#39;&#39;java     System.out.println(str.equalsIgnoreCase(str2)); &#39;&#39;&#39;</code></pre></li><li><p>public String substring(int beginIndex, int endIndex)    根据开始和结束索引进行截取，得到新的字符串(包前不包后)</p><pre><code> &#39;&#39;&#39;java     String rar = &quot;学java死路一条&quot;;             System.out.println(rar.substring(0, 5)); &#39;&#39;&#39;</code></pre></li><li><p>public String substring(int beginIndex)      从传入的索引处截取，截取到末尾，得到新的字符串返回</p><pre><code> &#39;&#39;&#39;java     System.out.println(rar.substring(5)); &#39;&#39;&#39;</code></pre></li><li><p>public String replace(CharSequence target，CharSequence replacement)        使用新值，将字符串中的旧值替换，得到新的字符串</p><pre><code> &#39;&#39;&#39;java     System.out.println(rar.replace(&quot;学&quot;, &quot;卷&quot;)); &#39;&#39;&#39;</code></pre></li><li><p>public boolean contains(CharSequence s)          判断字符串中是否包含了某个字符串</p><pre><code> &#39;&#39;&#39;java     System.out.println(rar.contains(&quot;java&quot;)); &#39;&#39;&#39;</code></pre></li><li><p>public boolean startswith(string prefix)            判断字符串是否以某个字符串内容开头，开头返回true，反之</p><pre><code>&#39;&#39;&#39;java    System.out.println(rar.startsWith(&quot;学java&quot;));&#39;&#39;&#39;</code></pre></li><li><p>public String[] split(string regex)              把字符串按照某个字符串内容分割，并返回字符串数组回来    </p><pre><code>&#39;&#39;&#39;java    String string = &quot;呵呵哒，呵呵哒，呵呵哒&quot;;            String[] heheda = string.split(&quot;，&quot;);             for (int i = 0; i &lt; heheda.length; i++) &#123;                System.out.println(heheda[i]);            &#125;&#39;&#39;&#39;</code></pre></li></ol><h2 id="ArrayList类的常用方法"><a href="#ArrayList类的常用方法" class="headerlink" title="ArrayList类的常用方法"></a>ArrayList类的常用方法</h2><p>1. </p><p>add(E e)  将指定元素添加到集合的末尾</p><pre><code>    &#39;&#39;&#39;Java        ArrayList list = new ArrayList();        list.add(&quot;呵呵哒&quot;);        list.add(123);        list.add(1.22);        System.out.println(list);    &#39;&#39;&#39;</code></pre><p>2.<br>add(int i, E e) 往集合中的某个索引位置添加元素</p><pre><code>    &#39;&#39;&#39;Java        list.add(1, &quot;heheda&quot;);        list.add(1,&quot;呵&quot;);        System.out.println(list);    &#39;&#39;&#39;</code></pre><p>3.<br>get(int i)  获取指定索引位置的值</p><pre><code>    &#39;&#39;&#39;java        System.out.println(list.get(1));    &#39;&#39;&#39;</code></pre><p>4.<br>size()  返回集合中的元素数量</p><pre><code>    &#39;&#39;&#39;java        System.out.println(list.size());    &#39;&#39;&#39;</code></pre><p>5.<br>remove(int i)    删除指定索引位置的元素， 并返回删除的值</p><pre><code>    &#39;&#39;&#39;java        System.out.println(list.remove(1));     &#39;&#39;&#39;</code></pre><p>6.<br>remove(Object j)   删除指定的元素， 并返回删除是否成功</p><pre><code>    &#39;&#39;&#39;java        System.out.println(list.remove(&quot;呵&quot;));  //默认删除第一个出现的指定元素    &#39;&#39;&#39;</code></pre><p>7.<br>set(int i, Element e)  替换指定索引位置的元素, 并返回被修改的值</p><pre><code>    &#39;&#39;&#39;java        System.out.println(list.set(1, &quot;呵呵哒&quot;));    &#39;&#39;&#39;</code></pre><h1 id="包装类的一些方法"><a href="#包装类的一些方法" class="headerlink" title="包装类的一些方法"></a>包装类的一些方法</h1><h4 id="Objects类的常用方法"><a href="#Objects类的常用方法" class="headerlink" title="Objects类的常用方法"></a>Objects类的常用方法</h4><p>equals(Object a, Object b)  判断两个对象内容是否相等</p><pre><code>    &#39;&#39;&#39;java        String str = &quot;heheda&quot;;        String str2 = &quot;heheda&quot;;        System.out.println(str.equals(str2));  //原来这种方法有安全问题， 可能报空指针异常        System.out.println(Objects.equals(str, str2));    &#39;&#39;&#39;</code></pre><p>isNull(Object obj)  判断一个对象是否是null </p><pre><code>    &#39;&#39;&#39;java            String str = null;            String str2 = &quot;heheda&quot;;            // System.out.println(str.equals(str2));            System.out.println(Objects.equals(str, str2));            System.out.println(Objects.isNull(str));            System.out.println(Objects.isNull(str2));    &#39;&#39;&#39;</code></pre><p>nonNull(Object obj) 判断一个对象是否不是null</p><pre><code>    &#39;&#39;&#39;java        System.out.println(Objects.nonNull(str2));    &#39;&#39;&#39;</code></pre><h4 id="Interger类的常用方法-以此类推其他基本数据类型包装类"><a href="#Interger类的常用方法-以此类推其他基本数据类型包装类" class="headerlink" title="Interger类的常用方法, 以此类推其他基本数据类型包装类"></a>Interger类的常用方法, 以此类推其他基本数据类型包装类</h4><p>toString(int i)  </p><pre><code>    &#39;&#39;&#39;        Integer a = 123;//自动装箱        System.out.println(a.toString());        String str = Integer.toString(a);        System.out.println(str);        //自动拆箱        int a2 = a;    &#39;&#39;&#39;</code></pre><p>可以把基本数据类型转换成字符串数据类型</p><p>toString(double d)<br>toString()</p><pre><code>    &#39;&#39;&#39;        int a2 = a;        Integer.toString(a2);        String sttr = a.toString();    &#39;&#39;&#39;</code></pre><p>可以把字符串数值转换成对应数值的数据类型</p><p>parseInt(String str)<br>valueOf(String str)</p><pre><code>    &#39;&#39;&#39;        int i = Integer.parseInt(sttr);        int j = Integer.valueOf(sttr);    &#39;&#39;&#39;</code></pre><h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><p>append(任意类型)   &#x2F;&#x2F;添加各种类型的数据</p><pre><code>&#39;&#39;&#39;        StringBuilder stringBuilder = new StringBuilder(&quot;呵呵哒&quot;);        stringBuilder.append(1);        stringBuilder.append(&quot;呵呵哒&quot;);        stringBuilder.append(true);        System.out.println(stringBuilder);        //允许连续拼接        stringBuilder.append(&quot;呵呵哒&quot;).append(&quot;呵呵哒&quot;).append(111);&#39;&#39;&#39;</code></pre><p>reverse（）       &#x2F;&#x2F;将对象的内容反转</p><pre><code>&#39;&#39;&#39;    //反转操作    stringBuilder.reverse();    System.out.println(stringBuilder);&#39;&#39;&#39;</code></pre><p>length()       &#x2F;&#x2F;返回对象内容长度</p><pre><code>&#39;&#39;&#39;    stringBuilder.length();&#39;&#39;&#39;</code></pre><p>toString()            &#x2F;&#x2F;转换为String并返回内容</p><pre><code>&#39;&#39;&#39;    stringBuilder.toString();    &#39;&#39;&#39;</code></pre><p>###StringJoiner类 </p><p>public StringJoiner(间隔符)</p><pre><code>&#39;&#39;&#39;        StringJoiner str = new StringJoiner(&quot;, &quot;);        str.add(&quot;呵呵哒&quot;);        str.add(&quot;呵呵哒&quot;);        str.add(&quot;呵呵哒&quot;);        str.add(&quot;呵呵哒&quot;);        System.out.println(str);&#39;&#39;&#39;</code></pre><p>public StringJoiner(间隔符， 开始符号， 结束符号)</p><pre><code>&#39;&#39;&#39;    StringJoiner str2 = new StringJoiner(&quot;, &quot;,&quot;[&quot;,&quot;]&quot;);    str2.add(&quot;呵呵哒&quot;);    str2.add(&quot;呵呵哒&quot;);    str2.add(&quot;呵呵哒&quot;);    str2.add(&quot;呵呵哒&quot;);    System.out.println(str2);&#39;&#39;&#39;</code></pre><h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><p>System.exits()<br>Ststem.currentTimeMillis() 获取1970 1-1 0:0：0开始走到此刻的毫秒值<br>        ‘’’<br>                &#x2F;&#x2F;        System.exit(0);&#x2F;&#x2F;终止java虚拟机</p><pre><code>            long time1 = System.currentTimeMillis();            for (int i = 0; i &lt; 1000000; i++) &#123;                System.out.println(i);            &#125;            long time2 = System.currentTimeMillis();            String time = (time2 - time1)/ 1000.0 +&quot;s&quot;;            System.out.println(time);    &#39;&#39;&#39;</code></pre><h3 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h3><p>exit()  终止虚拟机操作， 一般不用</p><pre><code>    &#39;&#39;&#39;        // Runtime.getRuntime().exit(0);  //终止虚拟机    &#39;&#39;&#39;</code></pre><p>availableProcessors()  返回虚拟机能调用的处理器数量</p><pre><code>    &#39;&#39;&#39;        System.out.println(Runtime.getRuntime().availableProcessors()); //返回虚拟机能使用的处理器数量    &#39;&#39;&#39;</code></pre><p>totalMemory()   返回虚拟机中内存总量， long类型 字节</p><pre><code>    &#39;&#39;&#39;        System.out.println(Runtime.getRuntime().totalMemory());  //返回虚拟机中内存总量        System.out.println(Runtime.getRuntime().totalMemory() / 1024.0 / 1024.0 + &quot;MB&quot;);    &#39;&#39;&#39;</code></pre><p>freeMemory() 返回虚拟机中空闲的内存数量</p><pre><code>    &#39;&#39;&#39;        System.out.println(Runtime.getRuntime().freeMemory()/ 1024.0 / 1024.0 + &quot;MB&quot;);//返回虚拟机中空闲的内存数量    &#39;&#39;&#39;</code></pre><p>exec()  根据路径启动某个程序， 需要管理员权限</p><pre><code>    &#39;&#39;&#39;        Runtime.getRuntime().exec(&quot;D:\\Star Rail\\launcher.exe&quot;);  //启动 某个程序， idea需要管理员权限    &#39;&#39;&#39;</code></pre><p>Process.destroy();   &#x2F;&#x2F;用于结束通过exec启动的程序</p><pre><code>    &#39;&#39;&#39;        Process p = Runtime.getRuntime().exec(&quot;D:\\Star Rail\\launcher.exe&quot;);  //启动 某个程序， idea需要管理员权限, 返回Process类， 即软件对象        Thread.sleep(5000);  //让程序在此等待5s        p.destroy();  //结束这个软件    &#39;&#39;&#39;</code></pre><h3 id="BigDecimal类，-在java中-浮点类数据计算可能出现精度问题，-用BigDecimal类可以解决"><a href="#BigDecimal类，-在java中-浮点类数据计算可能出现精度问题，-用BigDecimal类可以解决" class="headerlink" title="BigDecimal类， 在java中 浮点类数据计算可能出现精度问题， 用BigDecimal类可以解决"></a>BigDecimal类， 在java中 浮点类数据计算可能出现精度问题， 用BigDecimal类可以解决</h3><pre><code>&#39;&#39;&#39;        BigDecimal a = BigDecimal.valueOf(0.1);        BigDecimal b = BigDecimal.valueOf(0.2);        System.out.println(a.add(b)); //加        System.out.println(a.subtract(b));  //减        System.out.println(a.multiply(b));  // 乘        System.out.println(a.divide(b));   //除        System.out.println(b.divide(a, 3, RoundingMode.HALF_UP));   //除数  精确几位， 舍入模式&#39;&#39;&#39;</code></pre><h3 id="Date类和Simpledateformat类"><a href="#Date类和Simpledateformat类" class="headerlink" title="Date类和Simpledateformat类"></a>Date类和Simpledateformat类</h3><pre><code>&#39;&#39;&#39;        Date d = new Date();        System.out.println(d);        long time = d.getTime();        System.out.println(time);        SimpleDateFormat s = new SimpleDateFormat(&quot;yyyy-MM-dd HH时mm分ss秒 EEE a&quot;);        System.out.println(s.format(time));        System.out.println(s.format(d));        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;);        System.out.println(simpleDateFormat.format(d));        simpleDateFormat.format(time);        String dtime = &quot;2022-12-12 12:11&quot;;        SimpleDateFormat s2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);        System.out.println(s2.parse(dtime));&#39;&#39;&#39;</code></pre><h3 id="Calander类"><a href="#Calander类" class="headerlink" title="Calander类"></a>Calander类</h3><pre><code>&#39;&#39;&#39;        Calendar ca = Calendar.getInstance();        System.out.println(ca);        int i = ca.get(Calendar.MONTH);             System.out.println(i);        ca.set(Calendar.MONTH, 10);        System.out.println(ca);        ca.add(Calendar.DAY_OF_YEAR, 10);        ca.add(Calendar.DAY_OF_YEAR, -10);        System.out.println(ca);&#39;&#39;&#39;</code></pre><h2 id="JDK8新增的时间日期类"><a href="#JDK8新增的时间日期类" class="headerlink" title="JDK8新增的时间日期类"></a>JDK8新增的时间日期类</h2><p>LocalDate :代表本地日期（年、月、日、星期）<br>LocalTime： 代表本地时间（时、分、秒、纳秒）<br>LocalDateTime：代表本地日期时间：（年、月、日、星期、时、分、秒、纳秒） &#x2F;&#x2F;用的最多</p><p>以LocalDate类为例：</p><p>‘’’<br>        LocalDate localDate &#x3D; LocalDate.now();<br>        System.out.println(localDate);<br>        System.out.println(localDate.getYear());<br>        System.out.println(localDate.getMonth());<br>        System.out.println(localDate.getDayOfMonth());<br>        System.out.println(localDate.getDayOfWeek().getValue());</p><pre><code>    LocalDate localDate1 = localDate.withYear(2099); //返回新的localdate类型， 原来的对象数据不变    System.out.println(localDate1);    System.out.println(localDate);    LocalDate localDate2 = localDate.withMonth(12); //返回新的localdate类型， 原来的对象数据不变    System.out.println(localDate2);    localDate.plusYears(2);  //加两年， 返回新的对象    localDate.minusYears(2); //减两年， 返回新的对象    LocalDate.of(2022, 12, 10);//获取指定时间对象， 返回新的对象    localDate.equals(localDate1); //判断日期对象是否相等    localDate.isAfter(localDate1); //判断日期是否在指定对象后面    localDate.isBefore(localDate1); //判断日期是否在指定对象后面</code></pre><p>‘’’<br>剩下的两类以此类推， 方法名是一样的<br>其中， LocalDateTime可以分开也可合并</p><p>‘’’<br>        LocalDate l1 &#x3D; localDateTime.toLocalDate(); &#x2F;&#x2F;分开<br>        LocalTime l2 &#x3D; localDateTime.toLocalTime();</p><pre><code>    LocalDateTime of = LocalDateTime.of(l1, l2);  //合并</code></pre><p>‘’’</p><h4 id="ZonId类和Instant类"><a href="#ZonId类和Instant类" class="headerlink" title="ZonId类和Instant类"></a>ZonId类和Instant类</h4><p>ZonId主要获取时区对象<br>Instant用以替代原来的DAte对象</p><p>‘’’</p><pre><code>    ZoneId z = ZoneId.systemDefault();    System.out.println(z.getId());    System.out.println(z);    System.out.println(ZoneId.getAvailableZoneIds());    ZoneId of = ZoneId.of(&quot;Asia/Aden&quot;);    System.out.println(of);    System.out.println(ZonedDateTime.now(of));    System.out.println(ZonedDateTime.now(Clock.systemUTC())); //世界标准时间    Instant i = Instant.now();    System.out.println(i.getEpochSecond());</code></pre><p>‘’’</p><h4 id="Period类和Duration类"><a href="#Period类和Duration类" class="headerlink" title="Period类和Duration类"></a>Period类和Duration类</h4><p>Period类用于计算两个localDAte类相差的年月日<br>Duration类用于计算两个时间对象相差的天、小时、分、秒、纳秒<br>用法同上或见API文档</p><p>‘’’<br>        LocalDate localDateTime1 &#x3D; LocalDate.of(2022, 11, 11);<br>        LocalDate localDateTime2 &#x3D; LocalDate.of(2023, 12, 12);</p><pre><code>    Period p = Period.between(localDateTime1, localDateTime2);    System.out.println(p.getYears());    System.out.println(p.getMonths());    LocalDateTime loc1 = LocalDateTime.of(2022, 2, 11, 12, 24, 48);    LocalDateTime loc2 = LocalDateTime.of(2022, 12, 12, 3, 48, 59);    Duration duration = Duration.between(loc1, loc2);    System.out.println(duration.toDays());</code></pre><p>‘’’</p><h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><p>‘’’<br>        LocalDate localDateTime1 &#x3D; LocalDate.of(2022, 11, 11);<br>        LocalDate localDateTime2 &#x3D; LocalDate.of(2023, 12, 12);</p><pre><code>    Period p = Period.between(localDateTime1, localDateTime2);    System.out.println(p.getYears());    System.out.println(p.getMonths());    LocalDateTime loc1 = LocalDateTime.of(2022, 2, 11, 12, 24, 48);    LocalDateTime loc2 = LocalDateTime.of(2022, 12, 12, 3, 48, 59);    Duration duration = Duration.between(loc1, loc2);    System.out.println(duration.toDays());    </code></pre><p>‘’’</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于主题配置位置的说明</title>
      <link href="/2023/09/22/%E5%85%B3%E4%BA%8E%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%AF%B4%E6%98%8E/"/>
      <url>/2023/09/22/%E5%85%B3%E4%BA%8E%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p>butterfly主题配置的文件处于Myblog\node_modules\hexo-theme-butterfly 中</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的试用文章</title>
      <link href="/2023/09/20/%E6%88%91%E7%9A%84%E8%AF%95%E7%94%A8%E6%96%87%E7%AB%A0/"/>
      <url>/2023/09/20/%E6%88%91%E7%9A%84%E8%AF%95%E7%94%A8%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落</p><p>示例段落示例段落示例段落</p><p>示例段落示例段落示例段落</p><p>示例段落示例段落示例段落</p><p><em>斜体文本</em></p><p><strong>粗体文本</strong></p><p><em><strong>粗斜体文本</strong></em></p><p>这是一个分隔符</p><hr><hr><p>* </p><p>- </p><hr><hr><hr><p><del>这是删除</del></p><p>这是无序列表</p><p>* </p><ul><li></li><li></li></ul><ul><li>一</li><li>二</li><li>三</li></ul><ul><li></li><li></li><li></li></ul><p>这是有序列表</p><p>1.<br>2.<br>3.  </p><ol><li>第一项<ul><li>子列表1</li><li>子列表2</li><li>子列表3</li></ul></li><li>第二项：<ul><li>子列表1</li><li>子列表2</li><li>子列表3</li></ul></li></ol><p>引用</p><blockquote><p>引用的内容</p><p>这是内容</p></blockquote><blockquote><p>第二段引用 的内容</p><p>这是内容</p></blockquote><p>区块嵌套</p><blockquote><p>引用</p><blockquote><p>引用</p></blockquote></blockquote><blockquote><blockquote><blockquote></blockquote><blockquote><blockquote></blockquote></blockquote></blockquote></blockquote><p>‘’’c</p><p>#include &lt;stdio.h&gt;</p><p>int main()</p><p>{</p><pre><code> printf(&quot;Hello World !&quot;);</code></pre><p>​return 0;</p><p>}</p><p>‘’’</p><p><a href="www.moussemou.cn">链接名称</a></p><p>&lt;<a href="http://www.moussemou.cn>">www.moussemou.cn&gt;</a></p><p><a href="https://www.msn.cn/zh-cn/news/other/%E8%B5%B5%E6%98%8E-%E8%8D%A3%E8%80%80%E5%9B%9E%E5%BD%92%E5%8D%8E%E4%B8%BA%E7%BB%9D%E6%97%A0%E5%8F%AF%E8%83%BD/ar-AA1gWELc?ocid=msedgntp&pc=EDGENTP&cvid=563da8064b7a40fc84fa3aff76c9c7c2&ei=6">图片描述</a></p><p>表格</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/09/19/hello-world/"/>
      <url>/2023/09/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
