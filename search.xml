<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>微服务相关</title>
      <link href="/2024/03/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9B%B8%E5%85%B3/"/>
      <url>/2024/03/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="注册eureka服务"><a href="#注册eureka服务" class="headerlink" title="注册eureka服务"></a>注册eureka服务</h2><pre><code>1.创建新的Maven模块2.创建springboot启动类    @EnableEurekaServer    @SpringBootApplication    public class EurekaApplication &#123;        public static void main(String[] args) &#123;            SpringApplication.run(EurekaApplication.class, args);            &#125;    &#125;3.引入eureka依赖     &lt;!--eureka依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;    &lt;/dependency&gt;4.创建application.yml文件 并编写配置信息server:    port: 10086   #服务端口， 即springboot启动端口， 不要与其他端口冲突spring:    application:    name: eurekaserice  #eureka的服务名称eureka:    client:    service-url:  #eureka的地址， eureka也是服务， 也会将自己注册进去        defaultZone: http://127.0.0.1:10086/eureka5. 运行启动类， 访问localhost:10086 即成功</code></pre><h3 id="在其他服务端注册eureka"><a href="#在其他服务端注册eureka" class="headerlink" title="在其他服务端注册eureka"></a>在其他服务端注册eureka</h3><pre><code>1.引入依赖    &lt;!--eureka依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;    &lt;/dependency&gt;2.在application.yml中填写配置信息即：spring:    application:    name: 呵呵哒service  #这里呵呵哒换成自定义的名字，例如：userserviceeureka:    client:    service-url:  #eureka的地址        defaultZone: http://127.0.0.1:10086/eureka3.在RestTemplate 的加入bean代码中加上@LoadBalanced注解</code></pre><h2 id="Ribbon负载均衡流程"><a href="#Ribbon负载均衡流程" class="headerlink" title="Ribbon负载均衡流程"></a>Ribbon负载均衡流程</h2><p>例：</p><pre><code>   1.order-service模块发送请求http://userservice/user/1 想要调用user-service服务   2.LoadBalancerInterceptor负载均衡拦截器就会拦截， 通过RibbonLoadBalancerClient拦截   获取URL中的服务id。   3.调用DynamicServerListLoadBalancer拉取eureka-server中的服务列表， 即获得所有的被调用的服务列表 例：localhost:8081, localhost:8082   4.DynamicServerListLoadBalancer获得返回到的服务列表调用IRule   5.IRule服务负载均衡   6.IRule选择其中某个服务， 然后返回给RibbonLoadBalancerClient。例如：轮询负载均衡   7.RibbonLoadBalancerClient修改url，再重新发起请求 此时请求为：                                       http://localhost:8081/user/1   8.成功请求到8081 IRule默认的负载均衡服务是ZoneAvoidanceRule 以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类， 这个Zone可以理解为一个机房，一个机架等。而后再对Zone内的多个服务做轮询。 一般中小型企业就是一个机房， 所以直接用默认的</code></pre><h3 id="通过定义IRule实现可以修改负载均衡规则，-有两种方式："><a href="#通过定义IRule实现可以修改负载均衡规则，-有两种方式：" class="headerlink" title="通过定义IRule实现可以修改负载均衡规则， 有两种方式："></a>通过定义IRule实现可以修改负载均衡规则， 有两种方式：</h3><pre><code>1.代码方式：在order-service中的OrderApplication类（即启动类）中，定义一个新的IRule        @Bean    public IRule randomRule()&#123;        return new RandomRule();     &#125;    此时就会由轮询变为随机这种方法会针对整个order-service调用的服务2.配置文件方式：在order-service中的application.yml文件中， 添加新的配置也可以修改规则        userservice:      ribbon:        NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule #此时就会由轮询变为随机    如要修改其他规则， 只需修改后面的RandomRule这种方法只针对某个服务而言， 这里只针对userservice这个服务</code></pre><h3 id="饥饿加载"><a href="#饥饿加载" class="headerlink" title="饥饿加载"></a>饥饿加载</h3><p>Ribbon默认是采用懒加载， 即第一次访问才会去创建LoadBalanceClient, 请求时间会很长。<br>而饥饿加载会在项目启动时创建， 降低第一次访问的耗时， 通过下面配置开启饥饿加载：</p><pre><code>写在application.yml配置文件中：ribbon:  eager-load:    enabled: true  #开启饥饿加载    clients: userservice  #指定对userservice这个服务饥饿加载    如有多个服务需要饥饿加载， 则换个行 再加上-  例如：    clients:       - userservice      - hehedaservice</code></pre><h2 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h2><p>Nacos默认端口8848 如需修改则去application.properties里面修改port<br><br>可以直接点击startup.cmd启动 也可在bin目录调起cmd 输入以下指令：<br></p><pre><code>startup.cmd -m standalone</code></pre><p>默认账号密码都是nacos</p><h3 id="服务注册到Nacos"><a href="#服务注册到Nacos" class="headerlink" title="服务注册到Nacos"></a>服务注册到Nacos</h3><pre><code>1.在cloud-demo父工程中添加spring-cloud-alibaba的管理依赖：        &lt;dependency&gt;        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;        &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;        &lt;type&gt;pom&lt;/type&gt;        &lt;scope&gt;import&lt;/scope&gt;    &lt;/dependency&gt;2.注释掉order-service和user-service中原有的eureka依赖3.添加nacos的客户端依赖， 即order-service和user-service的添加依赖&lt;!-- nacos客户端依赖包 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;    &lt;/dependency&gt;4.修改order-service和user-service的application.yml配置文件， 注释eureka地址， 添加nacos地址    spring:      cloud:        nacos:          server-addr: localhost:8848  #nacos服务地址5.启动并测试</code></pre><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><pre><code>一般来说， 一个机房或一个地域属于一个集群。在application.yml添加如下配置：    spring:        cloud:        nacos:            server-addr: localhost:8848  #nacos服务地址            discovery:              cluster-name: HZ  #配置集群名字， 例如HZ代指杭州Nacos服务分级存储模型：  1.一级是服务， 例如userservice  2.二级是集群， 例如杭州或上海  3.三级是实例， 例如杭州机房的某台服务器部署了userservice的服务器如果要设定优先访问本地集群， 则需要修改负载均衡规则添加以下配置：        userservice:      ribbon:        NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # 优先访问本地集群负载均衡规则 </code></pre><h3 id="服务的权重控制"><a href="#服务的权重控制" class="headerlink" title="服务的权重控制"></a>服务的权重控制</h3><pre><code>1.Nacos控制台可以设置实例的权重值，0~1之间2.同集群内的多个实例，权重越高被访问的频率越高3.权重设置为0则完全不会被访问</code></pre><h3 id="创建命名空间"><a href="#创建命名空间" class="headerlink" title="创建命名空间"></a>创建命名空间</h3><pre><code>  cloud:    nacos:      server-addr: localhost:8848  #nacos服务地址      discovery:        cluster-name: HZ  #配置集群名字， 例如HZ代指杭州        namespace: 3c98d090-f981-4c64-b560-01eb6d134607  #命名空间dev环境默认情况下，所有service、data、group都在同一个namespace，名为public不同namespace之间相互隔离，例如不同namespace的服务互相不可见namespace用来做环境隔离每个namespace都有唯一id， 不自己配置就是默认uuid不同的namespace下的服务不可见</code></pre><h2 id="Nacos与Eureka的区别"><a href="#Nacos与Eureka的区别" class="headerlink" title="Nacos与Eureka的区别"></a>Nacos与Eureka的区别</h2><p>Nacos的服务实例分为两种l类型：</p><ul><li><p>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。</p></li><li><p>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</p></li></ul><p>配置一个服务实例为永久实例：</p><pre><code>spring:  cloud:    nacos:      discovery:        ephemeral: false # 设置为非临时实例</code></pre><p>Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：</p><ul><li><p>Nacos与eureka的共同点</p><ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测</li></ul></li><li><p>Nacos与Eureka的区别</p><ul><li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li><li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li></ul></li></ul><h3 id="统一配置管理"><a href="#统一配置管理" class="headerlink" title="统一配置管理"></a>统一配置管理</h3><p>当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。</p><p>1）引入nacos-config依赖</p><p>首先，在user-service服务中，引入nacos-config的客户端依赖：</p><pre><code>&lt;!--nacos配置管理依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>2）添加bootstrap.yaml</p><p>然后，在user-service中添加一个bootstrap.yaml文件，内容如下：</p><pre><code>spring:  application:    name: userservice # 服务名称  profiles:    active: dev #开发环境，这里是dev   cloud:    nacos:      server-addr: localhost:8848 # Nacos地址      discovery:        namespace: 3c98d090-f981-4c64-b560-01eb6d134607  #命名空间dev环境      config:        file-extension: yaml # 文件后缀名</code></pre><h3 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h3><pre><code>最终的目的，是修改nacos中的配置后，微服务中无需重启即可让配置生效，也就是配置热更新。在user-service服务中，添加一个类，读取patterrn.dateformat属性：@Component@Data@ConfigurationProperties(prefix = &quot;pattern&quot;)public class PatternProperties &#123;    private String dateformat;&#125;</code></pre><h2 id="Feign替代RestTemplate"><a href="#Feign替代RestTemplate" class="headerlink" title="Feign替代RestTemplate"></a>Feign替代RestTemplate</h2><p>在order-service服务的pom文件中引入feign的依赖：</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>在order-service的启动类添加注解开启Feign的功能：</p><pre><code>@EnableFeignClients</code></pre><p>在order-service中新建一个接口，内容如下：</p><pre><code>@FeignClient(&quot;userservice&quot;)public interface UserClient &#123;    @GetMapping(&quot;/user/&#123;id&#125;&quot;)    User findById(@PathVariable(&quot;id&quot;) Long id);&#125;</code></pre><p>这个客户端主要是基于SpringMVC的注解来声明远程调用的信息，比如：</p><ul><li>服务名称：userservice</li><li>请求方式：GET</li><li>请求路径：&#x2F;user&#x2F;{id}</li><li>请求参数：Long id</li><li>返回值类型：User</li></ul><p>这样，Feign就可以帮助发送http请求，无需自己使用RestTemplate来发送了。<br><br>修改order-service中的OrderService类中的queryOrderById方法，使用Feign客户端代替RestTemplate：</p><pre><code>public Order queryOrderById(Long orderId) &#123;    Order order = orderMapper.findById(orderId);    User user = userClient.findById(order.getUserId());    order.setUser(user);    return order;&#125;</code></pre><h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><p>Feign可以支持很多的自定义配置，如下表所示：</p><table><thead><tr><th>类型</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><strong>feign.Logger.Level</strong></td><td>修改日志级别</td><td>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td></tr><tr><td>feign.codec.Decoder</td><td>响应结果的解析器</td><td>http远程调用的结果做解析，例如解析json字符串为java对象</td></tr><tr><td>feign.codec.Encoder</td><td>请求参数编码</td><td>将请求参数编码，便于通过http请求发送</td></tr><tr><td>feign. Contract</td><td>支持的注解格式</td><td>默认是SpringMVC的注解</td></tr><tr><td>feign. Retryer</td><td>失败重试机制</td><td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td></tr></tbody></table><p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean覆盖默认Bean即可。<br><br>基于配置文件修改feign的日志级别可以针对单个服务：</p><pre><code>feign:    client:    config:       userservice: # 针对某个微服务的配置        loggerLevel: FULL #  日志级别 </code></pre><p>也可以针对所有服务：</p><pre><code>feign:    client:    config:       default: # 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置        loggerLevel: FULL #  日志级别 </code></pre><h2 id="Feign使用优化"><a href="#Feign使用优化" class="headerlink" title="Feign使用优化"></a>Feign使用优化</h2><p>Feign底层发起http请求，依赖于其它的框架。其底层客户端实现包括：</p><p>•URLConnection：默认实现，不支持连接池</p><p>•Apache HttpClient ：支持连接池</p><p>•OKHttp：支持连接池</p><p>因此提高Feign的性能主要手段就是使用<strong>连接池</strong>代替默认的URLConnection。</p><p>这里我们用Apache的HttpClient来演示。</p><p>1）引入依赖</p><p>在order-service的pom文件中引入Apache的HttpClient依赖：</p><pre><code>&lt;!--httpClient的依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;    &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>2）配置连接池</p><p>在order-service的application.yml中添加配置：</p><pre><code>feign:    client:        config:        default: # default全局的配置            loggerLevel: BASIC # 日志级别，BASIC就是基本的请求和响应信息    httpclient:        enabled: true # 开启feign对HttpClient的支持        max-connections: 200 # 最大的连接数        max-connections-per-route: 50 # 每个路径的最大连接数</code></pre><p>总结，Feign的优化：</p><p>1.日志级别尽量用basic</p><p>2.使用HttpClient或OKHttp代替URLConnection</p><p>①  引入feign-httpClient依赖</p><p>②  配置文件开启httpClient功能，设置连接池参数</p><h2 id="Gateway服务网关"><a href="#Gateway服务网关" class="headerlink" title="Gateway服务网关"></a>Gateway服务网关</h2><p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p><h3 id="为什么需要网关"><a href="#为什么需要网关" class="headerlink" title="为什么需要网关"></a>为什么需要网关</h3><p>Gateway网关是我们服务的守门神，所有微服务的统一入口。</p><p>网关的<strong>核心功能特性</strong>：</p><ul><li>请求路由</li><li>权限控制</li><li>限流</li></ul><p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p><p><strong>路由和负载均衡</strong>：一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p><p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p><p>在SpringCloud中网关的实现包括两种：</p><ul><li>gateway</li><li>zuul</li></ul><p>Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p><p>新建模块引入依赖：</p><pre><code>&lt;!--网关--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--nacos服务发现依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>编写启动类：</p><pre><code>package cn.itcast.gateway;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class GatewayApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(GatewayApplication.class, args);    &#125;&#125;</code></pre><p>编写基础配置和路由规则</p><pre><code>server:  port: 10010 # 网关端口spring:  application:    name: gateway # 服务名称  cloud:    nacos:      server-addr: localhost:8848 # nacos地址gateway:  routes: # 网关路由配置    - id: user-service # 路由id，自定义，只要唯一即可      # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址      uri: lb://userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称      predicates: # 路由断言，也就是判断请求是否符合路由规则的条件        - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求</code></pre><p>我们将符合<code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址。</p><p>本例中，我们将 <code>/user/**</code>开头的请求，代理到<code>lb://userservice</code>，lb是负载均衡，根据服务名拉取服务列表，实现负载均衡。<br><br>重启网关，访问<a href="http://localhost:10010/user/1%E6%97%B6%EF%BC%8C%E7%AC%A6%E5%90%88%60/user/**%60%E8%A7%84%E5%88%99%EF%BC%8C%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%88%B0uri%EF%BC%9Ahttp://userservice/user/1%EF%BC%8C%E5%BE%97%E5%88%B0%E4%BA%86%E7%BB%93%E6%9E%9C">http://localhost:10010/user/1时，符合`/user/**`规则，请求转发到uri：http://userservice/user/1，得到了结果</a></p><p>总结：</p><p>网关搭建步骤：</p><ol><li><p>创建项目，引入nacos服务发现和gateway依赖</p></li><li><p>配置application.yml，包括服务基本信息、nacos地址、路由</p></li></ol><p>路由配置包括：</p><ol><li><p>路由id：路由的唯一标示</p></li><li><p>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</p></li><li><p>路由断言（predicates）：判断路由的规则，</p></li><li><p>路由过滤器（filters）：对请求或响应做处理</p></li></ol><h3 id="自定义全局过滤器"><a href="#自定义全局过滤器" class="headerlink" title="自定义全局过滤器"></a>自定义全局过滤器</h3><p>需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：</p><ul><li><p>参数中是否有authorization，</p></li><li><p>authorization参数值是否为admin</p></li></ul><p>如果同时满足则放行，否则拦截</p><p>实现：</p><p>在gateway模块中定义一个过滤器：</p><pre><code>@Order(-1)@Componentpublic class AuthorizeFilter implements GlobalFilter &#123;    @Override    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;        // 1.获取请求参数        MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams();        // 2.获取authorization参数        String auth = params.getFirst(&quot;authorization&quot;);        // 3.校验        if (&quot;admin&quot;.equals(auth)) &#123;            // 放行            return chain.filter(exchange);        &#125;        // 4.拦截        // 4.1.禁止访问，设置状态码        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);        // 4.2.结束处理        return exchange.getResponse().setComplete();    &#125;&#125;</code></pre><h3 id="什么是跨域问题"><a href="#什么是跨域问题" class="headerlink" title="什么是跨域问题"></a>什么是跨域问题</h3><p>跨域：域名不一致就是跨域，主要包括：</p><ul><li><p>域名不同： <a href="http://www.taobao.com/">www.taobao.com</a> 和 <a href="http://www.taobao.org/">www.taobao.org</a> 和 <a href="http://www.jd.com/">www.jd.com</a> 和 miaosha.jd.com</p></li><li><p>域名相同，端口不同：localhost:8080和localhost8081</p></li></ul><p>跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题</p><h3 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h3><p>在gateway服务的application.yml文件中，添加下面的配置：</p><pre><code>spring:  cloud:    gateway:    # 。。。      globalcors: # 全局的跨域处理        add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题        corsConfigurations:        &#39;[/**]&#39;:            allowedOrigins: # 允许哪些网站的跨域请求               - &quot;http://localhost:8090&quot;            allowedMethods: # 允许的跨域ajax的请求方式              - &quot;GET&quot;              - &quot;POST&quot;              - &quot;DELETE&quot;              - &quot;PUT&quot;              - &quot;OPTIONS&quot;            allowedHeaders: &quot;*&quot; # 允许在请求中携带的头信息            allowCredentials: true # 是否允许携带cookie            maxAge: 360000 # 这次跨域检测的有效期</code></pre><h2 id="DocKer"><a href="#DocKer" class="headerlink" title="DocKer"></a>DocKer</h2><p>Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</p><ul><li>Docker允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li><li>Docker应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li></ul><p>Docker如何解决开发、测试、生产环境有差异的问题？</p><ul><li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li></ul><p>Docker是一个快速交付应用、运行应用的技术，具备下列优势：</p><ul><li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统</li><li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li><li>启动、移除都可以通过一行命令完成，方便快捷</li></ul><h3 id="Docker在centos7的安装"><a href="#Docker在centos7的安装" class="headerlink" title="Docker在centos7的安装"></a>Docker在centos7的安装</h3><p>如果之前安装过旧版本的Docker，可以使用下面命令卸载：</p><pre><code>yum remove docker \                docker-client \                docker-client-latest \                docker-common \                docker-latest \                docker-latest-logrotate \                docker-logrotate \                docker-selinux \                docker-engine-selinux \                docker-engine \                docker-ce</code></pre><p>首先需要虚拟机联网，安装yum工具</p><pre><code>yum install -y yum-utils \        device-mapper-persistent-data \        lvm2 --skip-broken</code></pre><p>然后更新本地镜像源：</p><h1 id="设置docker镜像源"><a href="#设置docker镜像源" class="headerlink" title="设置docker镜像源"></a>设置docker镜像源</h1><pre><code>yum-config-manager \    --add-repo \    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo    sed -i &#39;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#39; /etc/yum.repos.d/docker-ce.repoyum makecache fast</code></pre><p>然后输入命令：</p><pre><code>yum install -y docker-ce</code></pre><p>Docker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议直接关闭防火墙</p><pre><code># 关闭systemctl stop firewalld# 禁止开机启动防火墙systemctl disable firewalld</code></pre><p>通过命令启动docker：</p><pre><code>systemctl start docker  # 启动docker服务systemctl stop docker  # 停止docker服务systemctl restart docker  # 重启docker服务</code></pre><p>然后输入命令，可以查看docker版本：</p><pre><code>docker -v</code></pre><p>docker官方镜像仓库网速较差，我们需要设置国内镜像服务：</p><p>参考阿里云的镜像加速文档：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p><h2 id="Docker的基本操作"><a href="#Docker的基本操作" class="headerlink" title="Docker的基本操作"></a>Docker的基本操作</h2><h3 id="镜像名称"><a href="#镜像名称" class="headerlink" title="镜像名称"></a>镜像名称</h3><p>首先来看下镜像的名称组成：</p><ul><li>镜名称一般分两部分组成：[repository]:[tag]。 例如：Redis:latest</li><li>在没有指定tag时，默认是latest，代表最新版本的镜像<br>从DockerHub中拉取一个nginx镜像并查看</li></ul><p>1）首先去镜像仓库搜索nginx镜像，比如<a href="https://hub.docker.com/">DockerHub</a><br><br>2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：</p><pre><code>docker pull nginx</code></pre><p>3） </p><pre><code>通过命令：docker images 查看拉取到的镜像</code></pre><p>利用docker xx –help命令查看docker save和docker load的语法<br><br>例如，查看save命令用法，可以输入命令：</p><pre><code>docker save --help命令格式：docker save -o [保存的目标文件名称] [镜像名称]使用docker save导出镜像到磁盘 运行命令：docker save -o nginx.tar nginx:latest使用docker load加载镜像先删除本地的nginx镜像：docker rmi nginx:latest然后运行命令，加载本地文件：docker load -i nginx.tar</code></pre><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>需求：去DockerHub搜索并拉取一个Redis镜像</p><p>目标：</p><p>1）去DockerHub搜索Redis镜像</p><pre><code>去DockerHub官网查看， 也可去国内镜像网站</code></pre><p>2）查看Redis镜像的名称和版本</p><pre><code>docker images</code></pre><p>3）利用docker pull命令拉取镜像</p><pre><code>docker pull redis</code></pre><p>4）利用docker save命令将 redis:latest打包为一个redis.tar包</p><pre><code>docker save -o redis.tar redis:latest注：-o是output的意思</code></pre><p>5）利用docker rmi 删除本地的redis:latest</p><pre><code>docker rmi redis:latest</code></pre><p>6）利用docker load 重新加载 redis.tar文件</p><pre><code>docker load -i redis.tar注：-i是input的意思</code></pre><h3 id="创建并运行一个容器"><a href="#创建并运行一个容器" class="headerlink" title="创建并运行一个容器"></a>创建并运行一个容器</h3><pre><code>docker run --name containerName -p 80:80 -d nginx</code></pre><p>命令解读：</p><ul><li>docker run ：创建并运行一个容器</li><li>–name : 给容器起一个名字，比如叫做mn</li><li>-p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</li><li>-d：后台运行容器</li><li>nginx：镜像名称，例如nginx</li></ul><p>这里的<code>-p</code>参数，是将容器端口映射到宿主机端口。</p><p>默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。</p><p>现在，将容器的80与宿主机的80关联起来，当我们访问宿主机的80端口时，就会被映射到容器的80，这样就能访问到nginx了</p><p>docker run命令的常见参数：</p><ul><li>–name：指定容器名称</li><li>-p：指定端口映射</li><li>-d：让容器后台运行</li></ul><p>查看容器日志的命令：</p><ul><li>docker logs</li><li>添加 -f 参数可以持续查看日志</li></ul><p>查看容器状态：</p><ul><li>docker ps</li><li>docker ps -a 查看所有容器，包括已经停止的</li></ul><p>docker run命令的常见参数有哪些？</p><ul><li>–name：指定容器名称</li><li>-p：指定端口映射</li><li>-d：让容器后台运行</li></ul><p>查看容器日志的命令：</p><ul><li>docker logs</li><li>添加 -f 参数可以持续查看日志</li></ul><p>查看容器状态：</p><ul><li>docker ps</li><li>docker ps -a 查看所有容器，包括已经停止的</li></ul><h3 id="数据卷操作"><a href="#数据卷操作" class="headerlink" title="数据卷操作"></a>数据卷操作</h3><p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p><ul><li>create 创建一个volume</li><li>inspect 显示一个或多个volume的信息</li><li>ls 列出所有的volume</li><li>prune 删除未使用的volume</li><li>rm 删除一个或多个指定的volume</li></ul><p>① 创建数据卷</p><pre><code>docker volume create heheda</code></pre><p>② 查看所有数据</p><pre><code>docker volume ls</code></pre><p>③ 查看数据卷详细信息卷</p><pre><code>docker volume inspect heheda</code></pre><p>④ 删除数据卷</p><pre><code>docker  volume rm heheda</code></pre><p>数据卷的作用：</p><ul><li>将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全</li></ul><p>数据卷操作：</p><ul><li>docker volume create：创建数据卷</li><li>docker volume ls：查看所有数据卷</li><li>docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置</li><li>docker volume rm：删除指定数据卷</li><li>docker volume prune：删除所有未使用的数据卷</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HttpClient</title>
      <link href="/2024/03/11/HttpClient/"/>
      <url>/2024/03/11/HttpClient/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA中操作httpclient"><a href="#JAVA中操作httpclient" class="headerlink" title="JAVA中操作httpclient"></a>JAVA中操作httpclient</h1><h2 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h2><pre><code>    //创建httpclient对象    CloseableHttpClient httpClient = HttpClients.createDefault();    //创建请求对象    HttpGet httpGet = new HttpGet(&quot;http://localhost:80/user/shop/status&quot;);    //发送请求， 接受响应结果    CloseableHttpResponse response = httpClient.execute(httpGet);    //获取服务端返回的状态码    int statusCode = response.getStatusLine().getStatusCode();    System.out.println(&quot;服务端返回的状态码为：&quot; + statusCode);    HttpEntity entity = response.getEntity();    String body = EntityUtils.toString(entity);    System.out.println(&quot;服务端返回的数据为：&quot; + body);    //关闭资源    response.close();    httpClient.close();    </code></pre><h2 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h2><pre><code>    //创建httpclient对象    CloseableHttpClient httpClient = HttpClients.createDefault();    //创建请求对象    HttpPost httpPost = new HttpPost(&quot;http://localhost:8080/admin/employee/login&quot;);    JSONObject jsonObject = new JSONObject();    jsonObject.put(&quot;username&quot;, &quot;admin&quot;);    jsonObject.put(&quot;password&quot;, &quot;123456&quot;);    StringEntity stringEntity = new StringEntity(jsonObject.toString());    //指定请求编码方式    stringEntity.setContentEncoding(&quot;utf-8&quot;);    //数据格式    stringEntity.setContentType(&quot;application/json&quot;);    httpPost.setEntity(stringEntity);    //发送请求    CloseableHttpResponse response = httpClient.execute(httpPost);    int statusCode = response.getStatusLine().getStatusCode();    System.out.println(&quot;响应码为：&quot; + statusCode);    HttpEntity entity = response.getEntity();    String body = EntityUtils.toString(entity);    System.out.println(&quot;相应数据为：&quot; + body);    //关闭资源    response.close();    httpClient.close();</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis常用命令</title>
      <link href="/2024/03/10/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2024/03/10/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h1><h2 id="set-key-value"><a href="#set-key-value" class="headerlink" title="set key value"></a>set key value</h2><pre><code>set name mousse</code></pre><h2 id="get-key-返回value"><a href="#get-key-返回value" class="headerlink" title="get key  &#x2F;&#x2F;返回value"></a>get key  &#x2F;&#x2F;返回value</h2><pre><code>get name</code></pre><h2 id="setex-key-seconds-value-设置指定秒数有效期"><a href="#setex-key-seconds-value-设置指定秒数有效期" class="headerlink" title="setex key seconds value  &#x2F;&#x2F;设置指定秒数有效期"></a>setex key seconds value  &#x2F;&#x2F;设置指定秒数有效期</h2><pre><code>set name 30 mousse  //30s后自动消失</code></pre><h2 id="setnx-key-value-如若key不存在，-则创建"><a href="#setnx-key-value-如若key不存在，-则创建" class="headerlink" title="setnx key value &#x2F;&#x2F;如若key不存在， 则创建"></a>setnx key value &#x2F;&#x2F;如若key不存在， 则创建</h2><pre><code>setnx name mousse  //key name 已存在 所以不会创建</code></pre><h1 id="哈希操作命令"><a href="#哈希操作命令" class="headerlink" title="哈希操作命令"></a>哈希操作命令</h1><h2 id="hset-key-field-value"><a href="#hset-key-field-value" class="headerlink" title="hset key field value"></a>hset key field value</h2><pre><code>hset 100 name hehedahset 100 age 22</code></pre><h2 id="get-key-field-返回value"><a href="#get-key-field-返回value" class="headerlink" title="get key field  &#x2F;&#x2F;返回value"></a>get key field  &#x2F;&#x2F;返回value</h2><pre><code>hget 100 namehget 100 age</code></pre><h2 id="hdel-key-field-删除指定field"><a href="#hdel-key-field-删除指定field" class="headerlink" title="hdel key field  &#x2F;&#x2F;删除指定field"></a>hdel key field  &#x2F;&#x2F;删除指定field</h2><pre><code>hdel 100 name</code></pre><h2 id="hkeys-key-返回所有字段名称"><a href="#hkeys-key-返回所有字段名称" class="headerlink" title="hkeys key &#x2F;&#x2F;返回所有字段名称"></a>hkeys key &#x2F;&#x2F;返回所有字段名称</h2><pre><code>hkeys 100</code></pre><h2 id="hvals-100-返回指定key的所有值"><a href="#hvals-100-返回指定key的所有值" class="headerlink" title="hvals 100 &#x2F;&#x2F;返回指定key的所有值"></a>hvals 100 &#x2F;&#x2F;返回指定key的所有值</h2><pre><code>hvals 100</code></pre><h1 id="列表操作命令"><a href="#列表操作命令" class="headerlink" title="列表操作命令"></a>列表操作命令</h1><h2 id="lpush-key-value1-value2-将一个值或多个值插入列表头部"><a href="#lpush-key-value1-value2-将一个值或多个值插入列表头部" class="headerlink" title="lpush key value1 [value2] 将一个值或多个值插入列表头部"></a>lpush key value1 [value2] 将一个值或多个值插入列表头部</h2><pre><code>lpush mylist a b clpush mylist d</code></pre><h2 id="lrange-key-start-end-遍历列表，-指定从哪到哪"><a href="#lrange-key-start-end-遍历列表，-指定从哪到哪" class="headerlink" title="lrange key start end  &#x2F;&#x2F;遍历列表， 指定从哪到哪"></a>lrange key start end  &#x2F;&#x2F;遍历列表， 指定从哪到哪</h2><pre><code>lrange mylist 0 -1  //表示从头遍历到尾</code></pre><h2 id="rpop-key-移除尾部的值并返回"><a href="#rpop-key-移除尾部的值并返回" class="headerlink" title="rpop key  &#x2F;&#x2F;移除尾部的值并返回"></a>rpop key  &#x2F;&#x2F;移除尾部的值并返回</h2><pre><code>rpop mylist</code></pre><h2 id="llen-key-返回列表长度"><a href="#llen-key-返回列表长度" class="headerlink" title="llen key &#x2F;&#x2F;返回列表长度"></a>llen key &#x2F;&#x2F;返回列表长度</h2><pre><code>llen mylist</code></pre><h1 id="集合操作命令"><a href="#集合操作命令" class="headerlink" title="集合操作命令"></a>集合操作命令</h1><h2 id="添加集合成员-sadd-key-member1-menber2-可一次添加多个-不可重复-无序"><a href="#添加集合成员-sadd-key-member1-menber2-可一次添加多个-不可重复-无序" class="headerlink" title="添加集合成员 sadd key member1 menber2 &#x2F;&#x2F;可一次添加多个  不可重复  无序"></a>添加集合成员 sadd key member1 menber2 &#x2F;&#x2F;可一次添加多个  不可重复  无序</h2><pre><code>sadd set1 a b c d</code></pre><h2 id="smembers-key返回所有集合成员"><a href="#smembers-key返回所有集合成员" class="headerlink" title="smembers key返回所有集合成员"></a>smembers key返回所有集合成员</h2><pre><code>smembers set1</code></pre><h2 id="scard-key-返回集合成员个数"><a href="#scard-key-返回集合成员个数" class="headerlink" title="scard key 返回集合成员个数"></a>scard key 返回集合成员个数</h2><pre><code>scard set1</code></pre><h2 id="sinter-key1-key2-返回两个集合的交集"><a href="#sinter-key1-key2-返回两个集合的交集" class="headerlink" title="sinter key1 key2 返回两个集合的交集"></a>sinter key1 key2 返回两个集合的交集</h2><pre><code>sinter set1 set2</code></pre><h2 id="sunion-key1-key2-返回两个集合的并集"><a href="#sunion-key1-key2-返回两个集合的并集" class="headerlink" title="sunion key1 key2 返回两个集合的并集"></a>sunion key1 key2 返回两个集合的并集</h2><pre><code>sunion set1 set2</code></pre><h2 id="srem-key-member-删除集合指定元素"><a href="#srem-key-member-删除集合指定元素" class="headerlink" title="srem key member  删除集合指定元素"></a>srem key member  删除集合指定元素</h2><pre><code>srem set1 a</code></pre><h1 id="有序集合操作命令-按照分数由降序排行顺序（图像化界面）"><a href="#有序集合操作命令-按照分数由降序排行顺序（图像化界面）" class="headerlink" title="有序集合操作命令  按照分数由降序排行顺序（图像化界面）"></a>有序集合操作命令  按照分数由降序排行顺序（图像化界面）</h1><h2 id="zadd-key-score1-member1-score2-member2-添加成员"><a href="#zadd-key-score1-member1-score2-member2-添加成员" class="headerlink" title="zadd key score1 member1 score2 member2  添加成员"></a>zadd key score1 member1 score2 member2  添加成员</h2><pre><code>zadd zset1 10.0 a 10.5 bzadd zset1 10.2 c</code></pre><h2 id="zrange-key-start-end-指定从哪到哪遍历-默认升序排列"><a href="#zrange-key-start-end-指定从哪到哪遍历-默认升序排列" class="headerlink" title="zrange key start end 指定从哪到哪遍历 默认升序排列"></a>zrange key start end 指定从哪到哪遍历 默认升序排列</h2><pre><code>zrange zset1 0 -1 //从头到尾进行遍历</code></pre><h2 id="zincrby-key-score-member-给指定成员加分数并返回"><a href="#zincrby-key-score-member-给指定成员加分数并返回" class="headerlink" title="zincrby key score member  &#x2F;&#x2F;给指定成员加分数并返回"></a>zincrby key score member  &#x2F;&#x2F;给指定成员加分数并返回</h2><pre><code>zincrby zset1 5 a   //给a这个成员添加5分</code></pre><h1 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a>Redis通用命令</h1><h2 id="keys-pattern"><a href="#keys-pattern" class="headerlink" title="keys pattern"></a>keys pattern</h2><pre><code>keys * //返回所有keykeys set*  //返回所有set开头的key</code></pre><h2 id="exists-key-判断指定key是否存在"><a href="#exists-key-判断指定key是否存在" class="headerlink" title="exists key &#x2F;&#x2F;判断指定key是否存在"></a>exists key &#x2F;&#x2F;判断指定key是否存在</h2><pre><code>exists name</code></pre><h2 id="type-key-返回指定key的类型"><a href="#type-key-返回指定key的类型" class="headerlink" title="type key  &#x2F;&#x2F;返回指定key的类型"></a>type key  &#x2F;&#x2F;返回指定key的类型</h2><pre><code>type name  //返回Stringtype set1  //返回set</code></pre><h2 id="del-key-删除指定key-可以同时删除多个"><a href="#del-key-删除指定key-可以同时删除多个" class="headerlink" title="del key  删除指定key, 可以同时删除多个"></a>del key  删除指定key, 可以同时删除多个</h2><pre><code>del namedel set1 set2</code></pre><h1 id="在JAVA中操作Redis"><a href="#在JAVA中操作Redis" class="headerlink" title="在JAVA中操作Redis"></a>在JAVA中操作Redis</h1><pre><code>//注入RedisTemplate对象@Autowiredprivate RedisTemplate redisTemplate;</code></pre><h2 id="获取各类型的Redis操作对象"><a href="#获取各类型的Redis操作对象" class="headerlink" title="获取各类型的Redis操作对象"></a>获取各类型的Redis操作对象</h2><pre><code>    ValueOperations valueOperations = redisTemplate.opsForValue();//操作字符串类型的对象    HashOperations hashOperations = redisTemplate.opsForHash();//操作哈希类型的对象    ListOperations listOperations = redisTemplate.opsForList();//操作列表类型的对象    SetOperations setOperations = redisTemplate.opsForSet();//操作集合类型的对象    ZSetOperations zSetOperations = redisTemplate.opsForZSet();//操作有序集合类型的对象</code></pre><h2 id="操作String类型的对象"><a href="#操作String类型的对象" class="headerlink" title="操作String类型的对象"></a>操作String类型的对象</h2><pre><code>    redisTemplate.opsForValue().set(&quot;heheda&quot;, &quot;呵呵哒&quot;);    String heheda = (String) redisTemplate.opsForValue().get(&quot;heheda&quot;);    System.out.println(heheda);    redisTemplate.opsForValue()            .set(&quot;heheda2&quot;, &quot;呵呵哒&quot;, 3, TimeUnit.MINUTES);//三分钟中后销毁    Object heheda2 = redisTemplate.opsForValue().get(&quot;heheda2&quot;);    System.out.println(heheda2);    redisTemplate.opsForValue().setIfAbsent(&quot;heehda&quot;, &quot;呵呵哒3&quot;);    System.out.println(redisTemplate.opsForValue().get(&quot;heheda&quot;));</code></pre><h2 id="操作哈希类型的对象"><a href="#操作哈希类型的对象" class="headerlink" title="操作哈希类型的对象"></a>操作哈希类型的对象</h2><pre><code>    HashOperations hashOperations = redisTemplate.opsForHash();    hashOperations.put(&quot;100&quot;, &quot;name&quot;, &quot;呵呵哒&quot;);    hashOperations.put(&quot;100&quot;, &quot;age&quot;, &quot;20&quot;);    System.out.println(hashOperations.get(&quot;100&quot;, &quot;name&quot;));    Set keys = hashOperations.keys(&quot;100&quot;);//获取指定key的所有key名称    System.out.println(keys);    List values = hashOperations.values(&quot;100&quot;);//获取指定key的所有值    System.out.println(values);    hashOperations.delete(&quot;100&quot;, &quot;age&quot;); //删除指定字段</code></pre><h2 id="操作列表类型的对象"><a href="#操作列表类型的对象" class="headerlink" title="操作列表类型的对象"></a>操作列表类型的对象</h2><pre><code>    ListOperations listOperations = redisTemplate.opsForList();    //从列表头部添加所有元素    listOperations.leftPushAll(&quot;mylist&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;);    //从列表头部添加元素    listOperations.leftPush(&quot;mylist&quot;, &quot;d&quot;);    //遍历指定列表(key)， 指定从哪到哪    List mylist = listOperations.range(&quot;mylist&quot;, 0, -1);    System.out.println(mylist);    //移除尾部的值并返回    listOperations.rightPop(&quot;mylist&quot;);    //获取指定(key)大小的列表    Long size = listOperations.size(&quot;mylist&quot;);    System.out.println(size);</code></pre><h2 id="操作集合类型的对象"><a href="#操作集合类型的对象" class="headerlink" title="操作集合类型的对象"></a>操作集合类型的对象</h2><pre><code>    SetOperations setOperations = redisTemplate.opsForSet();    //添加元素，指定key    setOperations.add(&quot;set1&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;);    setOperations.add(&quot;set2&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;x&quot;, &quot;y&quot;);    //获取集合（指定key）所有的值    Set set1 = setOperations.members(&quot;set1&quot;);    System.out.println(set1);    //获取集合（指定key）元素个数    Long size = setOperations.size(&quot;set1&quot;);    System.out.println(size);    //获取两个集合的交集元素 指定key    Set intersect = setOperations.intersect(&quot;set1&quot;, &quot;set2&quot;);    System.out.println(intersect);    //获取两个集合的并集元素 指定key    Set union = setOperations.union(&quot;set1&quot;, &quot;set2&quot;);    System.out.println(union);    //删除指定的元素并返回    setOperations.remove(&quot;set1&quot;, &quot;a&quot;, &quot;b&quot;);</code></pre><h2 id="操作有序集合类型的对象"><a href="#操作有序集合类型的对象" class="headerlink" title="操作有序集合类型的对象"></a>操作有序集合类型的对象</h2><pre><code>    ZSetOperations zSetOperations = redisTemplate.opsForZSet();    //添加元素 指定key和value和分数 默认按分数升序排序    zSetOperations.add(&quot;zset1&quot;, &quot;a&quot;, 10);    zSetOperations.add(&quot;zset1&quot;, &quot;b&quot;, 12);    zSetOperations.add(&quot;zset1&quot;, &quot;c&quot;, 9);    //遍历集合 指定从哪到哪    Set zset1 = zSetOperations.range(&quot;zset1&quot;, 0, -1);    System.out.println(zset1);    //给指定元素添加分数并返回    zSetOperations.incrementScore(&quot;zset1&quot;, &quot;c&quot;, 10);//给c加十分    //删除指定元素    zSetOperations.remove(&quot;zset1&quot;, &quot;a&quot;, &quot;b&quot;);</code></pre><h2 id="操作所有Redis对象"><a href="#操作所有Redis对象" class="headerlink" title="操作所有Redis对象"></a>操作所有Redis对象</h2><pre><code>    //获取所有key名称    Set keys = redisTemplate.keys(&quot;*&quot;);    System.out.println(keys);    //判断指定key是否存在    Boolean name = redisTemplate.hasKey(&quot;name&quot;);    Boolean set1 = redisTemplate.hasKey(&quot;set1&quot;);    //查询所有key的类型    for (Object key : keys) &#123;        DataType type = redisTemplate.type(key);        System.out.println(type.name());    &#125;    //删除指定key    redisTemplate.delete(&quot;mylist&quot;);</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql结构和索引</title>
      <link href="/2023/12/23/Mysql%E7%BB%93%E6%9E%84%E5%92%8C%E7%B4%A2%E5%BC%95/"/>
      <url>/2023/12/23/Mysql%E7%BB%93%E6%9E%84%E5%92%8C%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h2>结构基本语法</h2><pre><code>start transaction ; //开始， begin也可delete from tb_dept where id = 1;  //执行的命令delete from tb_emp where dept_id = 1; //执行的命令commit ;  //确定提交rollback ; //回滚操作 </code></pre><br><h2>索引的基本语法</h2><br>    <p>– 创建：<b>为tb_emp表的name字段建立一个索引。</b></p><pre><code>create index idx_emp_name on tb_emp(name);</code></pre><br>-- 查询：<b>查询tb_emp表的索引信息</b><pre><code>show index from tb_emp;</code></pre><br>-- 删除：<b>删除tb_emp表的name字段索引</b><pre><code>drop index idx_emp_name on tb_emp;</code></pre><br>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Sql-DQL</title>
      <link href="/2023/12/18/Sql-DQL/"/>
      <url>/2023/12/18/Sql-DQL/</url>
      
        <content type="html"><![CDATA[<h2>DQL - 查询语句</h2><br>-- <b>1，查询指定字段name, entrydate 并返回</b>    <pre><code>select name, entrydatefrom tb_emp;</code></pre><p>– <b>2. 查询返回所有字段</b></p><pre><code>select * from tb_emp;//一般不建议使用* 因为不直观， 性能差。</code></pre><p>– <b>3. 查询所有员工的name, entrydate, 并起别名（姓名、 入职日期）</b></p><pre><code>select name as &quot;姓名&quot;, entrydate as &#39;入职日期&#39; -- 单引号双引号都可， as可以省去， 不加引号也可from tb_emp;</code></pre><p>– <b>4. 查询已有的员工关联了哪几种职位（不要重复）</b>   </p><pre><code>select distinct job from tb_emp;</code></pre><br><h3>条件查询</h3><br><p>– <b>1.查询 姓名 为 杨逍 的员工</b></p><pre><code>select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_empwhere name = &#39;杨逍&#39;;</code></pre><p>– <b>2.查询 id小于等于5 的员工信息</b></p><pre><code>select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_empwhere id &lt;= 5;</code></pre><p>– <b>3.查询 没有分配职位 的员工信息</b></p><pre><code>select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_empwhere job is null;</code></pre><p>– <b>4.查询 有职位 的员工信息</b></p><pre><code>select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_empwhere not job is null;-- 另一种写法select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_empwhere  job is not null;</code></pre><p>– <b>5.查询 密码不等于123456 的员工信息</b></p><pre><code>select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_empwhere not password  = &#39;123456&#39;;</code></pre><p>– <b>6.查询 入职日期 在’2000-01-01’ (包含)到2010-01-01’(包含)之间的员工信息</b></p><pre><code>select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_empwhere entrydate between &#39;2000-01-01&#39; and &#39;2010-01-01&#39;;</code></pre><p>– <b>7.查询 入职时间 在‘2000-01-01’(包含)到2010-01-01’(包含)之间 且 性别为女 的员工信息</b></p><pre><code>select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_empwhere entrydate between &#39;2000-01-01&#39; and &#39;2010-01-01&#39;and gender = &#39;2&#39;;</code></pre><p>– <b>8.查询职位是2（讲师），3（学工主管），4（教研主管）的员工信息</b></p><pre><code>select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_empwhere job = &#39;2&#39; or job = &#39;3&#39; or job = &#39;4&#39;;select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_empwhere job in (2, 3, 4); -- 优化写法， 多选一的关系</code></pre><p>– <b>9.查询姓名为两个字的员工信息</b></p><pre><code>select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_empwhere name like &#39;__&#39;;</code></pre><p>– <b>10.查询姓张的员工信息</b></p><pre><code>select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_empwhere name like &#39;张%&#39;;</code></pre><br><h3>聚合函数</h3><br>-- <b>1. 统计该企业员工数量</b><pre><code>select count(*) from tb_emp; -- count(?) 值只要不为null即可统计， 一般建议使用*</code></pre><p>– <b>2. 统计该企业最早入职的员工</b></p><pre><code>select min(entrydate) from tb_emp;</code></pre><p>– <b>3. 统计该企业最迟入职的员工</b></p><pre><code>select max(entrydate) from tb_emp;</code></pre><p>– <b>4. 统计该企业员工ID的平均值</b></p><pre><code>select avg(id) from tb_emp;</code></pre><p>– <b>5. 统计该企业员工的ID之和</b></p><pre><code>select sum(id) from tb_emp;</code></pre><br><h3>分组查询</h3><br>-- <b>1.根据性别分组， 统计男性和女性员工的数量</b><pre><code>select gender, count(*) from tb_emp group by gender;</code></pre><p>– <b>2.先查询入职时间在’2015-01-01’（包含）以前的员工， 并对结果根据职位分组，获取员工数量大于等于2的职位</b></p><pre><code>select job, count(*) from tb_emp where entrydate &lt;= &#39;2015-01-01&#39;group by jobhaving count(*) &gt;= 2;</code></pre><br><h3>排序查询</h3><br>-- <b>1.根据入职时间， 对员工进行升序排序</b><pre><code>select * from tb_emporder by entrydate asc; -- 默认就是升序排序， 所以asc可以省略不写</code></pre><p>– <b>2.根据入职时间， 对员工进行降序排序</b></p><pre><code>select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_emporder by entrydate desc;</code></pre><p>– <b>3.根据入职时间，对公司的员工进行升序排序， 入职时间相同， 再按照 更新时间进行降序排序</b></p><pre><code>select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_emporder by entrydate, update_time desc; -- 当第一个字段相同时， 第二个排序才会生效</code></pre><br><h3>分页查询</h3><br>-- <b>1. 从起始索引0开始查询员工数据， 每页展示5条数据</b><pre><code>select * from tb_emp limit 0, 5;</code></pre><p>– <b>2. 查询第1页员工数据， 每页展示5条记录</b></p><pre><code>select * from tb_emp limit 0, 5;</code></pre><p>– <b>3. 查询第2页员工数据， 每页展示5条记录</b></p><pre><code>select * from tb_emp limit 5, 5;</code></pre><p>– <b>4. 查询第3页员工数据， 每页展示5条记录</b></p><pre><code>select * from tb_emp limit 10, 5;</code></pre><h3>起始索引 = （页码数-1）* 每页展示记录数</h3><br><h3>if在select中用法示例</h3><br><pre><code>select if(gender=1, &#39;男性&#39;, &#39;女性&#39;)as &#39;性别&#39;, count(*)from tb_emp group by gender;-- 如果是1， 则性别展示男， 如果是女， 则性别展示女</code></pre><br><h3>case用法示例</h3><br>    case 字段名 when 值 then 要改的值, <br>               when 值 then 要改的值,<br>               else 要改的值<br>               end<br><pre><code>select (case job when &#39;1&#39; then &#39;班主任&#39;        when &#39;2&#39; then &#39;讲师&#39;        when &#39;3&#39; then &#39;学工主管&#39;        when &#39;4&#39; then &#39;教研主管&#39;        else &#39;未分配职位&#39;        end) as &#39;职位&#39;, count(*)from tb_emp group by job;</code></pre><br><h3>内连接</h3><br>--<b>查询员工的姓名， 及说属的部门名称（隐式内连接实现）</b><pre><code>select tb_emp.name, tb_dept.name from tb_emp, tb_dept where tb_emp.dept_id = tb_dept.id;</code></pre><br><h3>外连接</h3><br>-- <b>查询员工姓名， 及所属部门名称（显示内连接实现）</b><pre><code>select tb_emp.name, tb_dept.name from tb_emp inner join tb_dept on tb_emp.dept_id = tb_dept.id;</code></pre><h3>外连接</h3>  //实际开发一般用左外连接<p>– <b>查询员工表所有员工的姓名， 和对应的部门名称（左外连接）</b></p><pre><code>select tb_emp.name, tb_dept.name from tb_emp left join tb_dept on tb_emp.dept_id = tb_dept.id;</code></pre><p>0</p><p>– <b>查询部门表所有部门的姓名， 和对应的员工名称（右外连接）</b></p><pre><code>select tb_dept.name, tb_emp.name from tb_emp right join tb_dept on tb_dept.id = dept_id;</code></pre><br><h3>子查询</h3><br>标量子查询<br>-- <b>查询教研部所有的员工信息</b><pre><code>select * from tb_emp where tb_emp.dept_id = (select id from tb_dept where name = &#39;教研部&#39;);</code></pre><p>– <b>查询在方东白入职之后的员工信息</b></p><pre><code>select * from tb_emp where entrydate &gt;       (select entrydate from tb_emp where tb_emp.name = &#39;方东白&#39;);</code></pre><br>列子查询<br><p>– <b>查询教研部和咨询部的所有员工信息</b></p><pre><code>select * from tb_emp where tb_emp.dept_id in(select id from tb_dept where tb_dept.name = &#39;教研部&#39; or tb_dept.name = &#39;咨询部&#39;);</code></pre><br>行子查询<br>-- <b>查询与韦一笑的入职日期及职位都相同的员工信息</b>    <pre><code>select * from tb_emp where (entrydate, job) = (select entrydate, job from tb_emp where name = &#39;韦一笑&#39;);</code></pre><br>表子查询<br>-- <b>查询入职日期是“2006-01-01”之后的员工信息， 及其部门名称</b><pre><code>select e.*, tb_dept.name from (select * from tb_emp where entrydate &gt;&#39;2006-01-01&#39;)e, tb_dept where e.dept_id = tb_dept.id;select tb_emp.*, tb_dept.name from tb_emp left join tb_dept on dept_id = tb_dept.id where entrydate&gt;&#39;2006-01-01&#39;;</code></pre><br>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Sql-DML</title>
      <link href="/2023/12/17/Sql-DML/"/>
      <url>/2023/12/17/Sql-DML/</url>
      
        <content type="html"><![CDATA[<br><h2>DML-insert 插入数据</h2><br><p>– <b>1.为tb_emp表的username, name, gender 字段添加值</b></p><pre><code>insert into tb_emp(username, name, gender, create_time, update_time) values(&#39;wuji&#39;,&#39;张无忌&#39;,1,now(),now());</code></pre><p>– <b>2.为tb_emp表的所有字段添加值</b></p><pre><code>insert into tb_emp values (null,&#39;zhiruo&#39;,&#39;123&#39;,&#39;周芷若&#39;,2,&#39;1.jpg&#39;,1,&#39;2010-01-01&#39;,now(),now());</code></pre><p>– <b>3.批量为tb_emp表的username, name, gender字段插入值</b></p><pre><code>insert into tb_emp(username, name, gender, create_time, update_time) values (&#39;weifuwang&#39;,&#39;韦一笑&#39;,1,now(),now()),(&#39;weiyimei&#39;,&#39;韦一梅&#39;,2,now(),now());</code></pre><br><h2>DML-update 更新数据</h2><br>-- <b>1.将tb_emp表的ID为1的员工 姓名name字段更新为‘张三’</b><pre><code>update tb_emp set name = &#39;张三&#39;, update_time = now() where id = 1;</code></pre><p>– <b>2.将tb_emp表的所有员工的入职日期更新为’2010-01-01’</b></p><pre><code>update tb_emp set entrydate = &#39;2010-01-01&#39;, update_time = now()</code></pre><br><h2>DML-delete 删除数据</h2><br>-- <b>1.删除tb_emp表中id为1的员工</b><pre><code>delete from tb_emp where id = 1;</code></pre><p>– <b>2.删除tb_emp表中的所有员工</b> &#x2F;&#x2F;危险操作<br><br>– delete不能删除某一个字段的值， 如果要删除， 可以使用update将字段值改为null</p><pre><code>delete from tb_emp;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Sql-DDL</title>
      <link href="/2023/12/17/Sql-DDL/"/>
      <url>/2023/12/17/Sql-DDL/</url>
      
        <content type="html"><![CDATA[<p>注： database可以替换为schema, 一般都用database见名知意</p><p>– <b>查询所有数据库</b></p><pre><code>SHOW DATABASES;</code></pre><p>– <b>创建数据库</b></p><pre><code>CREATE DATABASE db01;</code></pre><p>– <b>加上判断语句， 如果不存在才创建</b><br>– <b>如果存在， 不会报错，也不会执行任何操作</b></p><pre><code>CREATE DATABASE IF NOT EXISTS db02;</code></pre><p>– <b>切换数据库</b></p><pre><code>USE db01;</code></pre><p>– <b>查询当前正在使用的数据库</b></p><pre><code>SELECT DATABASE();</code></pre><p>– <b>删除数据库， 指定名字</b></p><pre><code>DROP DATABASE db02;</code></pre><p>– <b>加上判断语句， 如果存在该数据库， 才会删除</b></p><pre><code>DROP DATABASE IF EXISTS db02;</code></pre><h1> 约束 </h1><pre><code>not null     限制该字段值不能为空unique       保证字段的所有数据都是唯一的， 不重复的primary key  一行数据的主键， 也是唯一标识， 要求非空且唯一default      保存数据时，如果未指定该字段值， 则采用默认值foreign key  让两张表的数据建立联系， 保证数据的一致性和完整性</code></pre><p>– <b>建表</b></p><pre><code>-- auto_increment指自增create table tb_user(    id int primary key auto_increment comment &#39;ID, 唯一标识&#39;,    username varchar(20) not null unique comment &#39;用户名&#39;,    name varchar(20) not null comment &#39;姓名&#39;,    age int comment &#39;年龄&#39;,    gender char(1) default &#39;男&#39; comment &#39;性别&#39;)charset=utf8, comment &#39;用户表&#39;;</code></pre><h2>-- 修改表结构</h2><br>-- <b>为表tb_emp添加字段qq varchar(11)</b><pre><code>alter table tb_emp add qq varchar(11) comment &#39;QQ&#39;;</code></pre><p>– <b>修改表tb_emp字段类型 qq varchar(13)</b></p><pre><code>alter table tb_emp modify qq varchar(13) comment &#39;QQ&#39;;</code></pre><p>– <b>修改tb_emp字段名 qq 为 qq_num varchar(13)</b></p><pre><code>alter table tb_emp change qq qq_num varchar(13) comment &#39;QQ&#39;;</code></pre><p>– <b>删除tb_emp的qq_num字段</b></p><pre><code>alter table tb_emp drop column qq_num;</code></pre><p>– <b>将tb_emp表名修改为emp</b></p><pre><code>rename table tb_emp to emp;</code></pre><p>– <b>如果存在表， 则删除。</b> if exists可以去掉</p><pre><code>drop table if exists tb_emp;    </code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>注解</title>
      <link href="/2023/11/16/%E6%B3%A8%E8%A7%A3/"/>
      <url>/2023/11/16/%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><pre><code>&#39;&#39;&#39; 自定义的注解public @interface Mytest1 &#123;String name();  //属性名必须加括号String value();  //特殊值value&#125;&#39;&#39;&#39;&#39;&#39;&#39;@Mytest1(name = &quot;呵呵哒&quot;, value = &quot;1000&quot;)public class test1 &#123;@Mytest1(name = &quot;呵呵哒&quot;, value = &quot;1000&quot;)  //不用带分号public void heheda()&#123;    //暂不知有什么用&#125;&#125;&#39;&#39;&#39;</code></pre><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解就是用来修饰注解的注解</p><pre><code>&#39;&#39;&#39;在注解上面添加注解, Target例@Target(ElementType.TYPE)  //表示该注解只能用在类或接口上public @interface Mytest2 &#123;    &#125;@Mytest2public class test2 &#123;//    @Mytest2 //这里报错， 因为这个注解只能用在类或接口上&#125;&#39;&#39;&#39;&#39;&#39;&#39;Retention例//@Retention(RetentionPolicy.SOURCE)//只作用在源码阶段， 字节码文件不存在//@Retention(RetentionPolicy.CLASS)//默认值 保留到字节码文件阶段，运行阶段不存在@Retention(RetentionPolicy.RUNTIME)  //开发常用， 一直保留到运行阶段public @interface Mytest3 &#123;    &#125;&#39;&#39;&#39;</code></pre><h2 id="解析注解"><a href="#解析注解" class="headerlink" title="解析注解"></a>解析注解</h2><pre><code>&#39;&#39;&#39;  定义注解@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Mytest4 &#123;String value();double aaa();    String[] bbb();&#125;&#39;&#39;&#39;&#39;&#39;&#39;使用注解@Mytest4(value = &quot;111&quot;,aaa = 11.1,bbb = &#123;&quot;呵呵哒1&quot;&#125;)public class Demo &#123;    @Mytest4(value = &quot;222&quot;,aaa = 22.2,bbb = &#123;&quot;呵呵哒2&quot;&#125;)    public void test1()&#123;    &#125;&#125;&#39;&#39;&#39;&#39;&#39;&#39;解析注解public class AnnotationTest3 &#123;    @Test//获取类的注解内容    public void parceClass()&#123;        //先获取类对象        Class dc = Demo.class;        //判断该类是否包含某个注解        if (dc.isAnnotationPresent(Mytest4.class))&#123;            Mytest4 mytest4 = (Mytest4) dc.getDeclaredAnnotation(Mytest4.class);//获取这个注解            System.out.println(mytest4.value());    //获取注解的内容            System.out.println(mytest4.aaa());            System.out.println(Arrays.toString(mytest4.bbb()));        &#125;    &#125;    @Test //获取方法的注解内容    public void parceMethod() throws Exception&#123;        Class dc = Demo.class;        Method test1 = dc.getDeclaredMethod(&quot;test1&quot;);        //判断方法是否包含某个注解        if (test1.isAnnotationPresent(Mytest4.class))&#123;            Mytest4 methoddc = (Mytest4) test1.getDeclaredAnnotation(Mytest4.class);            System.out.println(methoddc.value());            System.out.println(methoddc.aaa());            System.out.println(Arrays.toString(methoddc.bbb()));        &#125;    &#125;&#125;&#39;&#39;&#39;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2023/11/14/%E5%8F%8D%E5%B0%84/"/>
      <url>/2023/11/14/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="获取类对象"><a href="#获取类对象" class="headerlink" title="获取类对象"></a>获取类对象</h2><pre><code>&#39;&#39;&#39;    Class c1 = Student.class;   //获取class对象    System.out.println(c1.getName());   //类名    System.out.println(c1.getSimpleName()); //简名， 就是类名    Class c2 = Class.forName(&quot;java_Olypic.Student&quot;);  //获取class对象    System.out.println(c2.getName());    System.out.println(c2.getSimpleName());    System.out.println(c1 == c2);  //指向的是同一个对象    Student s = new Student();    Class c3 = s.getClass();   //获取class对象    System.out.println(c3 == c2);  //指向的是同一个对象&#39;&#39;&#39;</code></pre><h2 id="获取构造器及利用构造器创建对象"><a href="#获取构造器及利用构造器创建对象" class="headerlink" title="获取构造器及利用构造器创建对象"></a>获取构造器及利用构造器创建对象</h2><pre><code>&#39;&#39;&#39;@Testpublic void testCatConstructors()&#123;    Class c1 = Cat.class;  //反射第一步， 获取类对象//        Constructor[] constructors = c1.getConstructors(); //获取该类的所有构造器， 只能获取public修饰的构造器    Constructor[] constructors = c1.getDeclaredConstructors(); //获取该类的所有构造器, 所有权限修饰的构造器都能获取    for (Constructor constructor : constructors) &#123;        System.out.println(constructor.getName() + &quot;----&gt;&quot;+constructor.getParameterCount());  //打印构造器名字和构造器需要获取的参数    &#125;&#125;@Testpublic void testCatConstructor() throws Exception&#123;    Class c1 = Cat.class;//        Constructor constructor1 = c1.getConstructor();  //获取指定某个构造器， 不填就是无参构造器, 只能获取public修饰的    Constructor con1 = c1.getDeclaredConstructor();//获取指定某个构造器， 不填就是无参构造器， 能获取所有权限修饰的构造器    con1.setAccessible(true);   //禁止检查访问权限！ 比如可以拿到private修饰的东西    Cat cat1 = (Cat) con1.newInstance();   //这里用强转， 反射一般不指定泛型    System.out.println(cat1);//        Constructor constructor2 = c1.getConstructor(String.class, int.class);  //获取指定某个构造器, 只能获取public修饰的    Constructor con2 = c1.getDeclaredConstructor(String.class, int.class); //获取指定某个构造器， 能获取所有权限修饰的构造器    con2.setAccessible(true);  //禁止检查访问权限    Cat cat2 = (Cat) con2.newInstance(&quot;呵呵哒&quot;, 12);  //通过制定构造器获取对象    System.out.println(cat2);//        System.out.println(con1.getName());//        System.out.println(con2.getName());&#125;&#39;&#39;&#39;</code></pre><h2 id="获取成员变量并使用"><a href="#获取成员变量并使用" class="headerlink" title="获取成员变量并使用"></a>获取成员变量并使用</h2><pre><code>&#39;&#39;&#39;    @Test    public void testCatField() throws Exception&#123;    Class c1 = Cat.class;    Field[] fields = c1.getDeclaredFields(); //获取所有成员变量    for (Field field : fields) &#123;        System.out.println(field.getType()+&quot;-----&gt;&quot;+field.getName()); //遍历所有变量类型和变量名字    &#125;    System.out.println(c1.getDeclaredField(&quot;name&quot;)); //返回指定名字的变量    Field fage = c1.getDeclaredField(&quot;age&quot;);    System.out.println(fage.getName() +&quot;----&gt;&quot;+ fage.getType());    Cat cat = new Cat();    fage.setAccessible(true);  //禁止检查权限    fage.set(cat, 12);    System.out.println(cat);    int integers = (int) fage.get(cat);    System.out.println(integers); &#125;&#39;&#39;&#39;</code></pre><h2 id="获取成员方法并使用"><a href="#获取成员方法并使用" class="headerlink" title="获取成员方法并使用"></a>获取成员方法并使用</h2><pre><code>&#39;&#39;&#39;@Testpublic void testCatMethod() throws Exception&#123;    Class c1 = Cat.class;    Method[] des = c1.getDeclaredMethods();//获取所有成员方法    for (Method de : des) &#123;        System.out.println(de.getName()+&quot;---&gt;&quot;+                de.getParameterCount() +&quot;-----&gt;&quot; +                de.getReturnType()); //获取方法名字和方法参数的个数和方法返回值类型    &#125;    Method tos = c1.getDeclaredMethod(&quot;toString&quot;);//获取指定方法 ，这里是无参方法所以不用填参数    System.out.println(tos.getName() + &quot;---&gt;&quot; + tos.getParameterCount() +&quot;----&quot;+ tos.getReturnType());    Method sa = c1.getDeclaredMethod(&quot;setAge&quot;, int.class);//获取指定方法， 有参数要写参数    System.out.println(sa.getName() + &quot;---&gt;&quot; + sa.getParameterCount() +&quot;----&quot;+  sa.getReturnType());    sa.setAccessible(true);  //设置禁止检查权限    Cat cat = new Cat();    Object ik = sa.invoke(cat, 12); //使用方法， 指定对象和写入参数， 返回方法返回值    System.out.println(ik);  //方法无返回值， 所以是null    tos.setAccessible(true);    Object ik2 = tos.invoke(cat);  //使用方法， 并返回方法返回值， 无参不需要传参数    System.out.println(ik2);  //打印返回值&#125;&#39;&#39;&#39;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网络编程类</title>
      <link href="/2023/11/13/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%B1%BB/"/>
      <url>/2023/11/13/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a>InetAddress类</h2><pre><code>&#39;&#39;&#39;    InetAddress ip1 = InetAddress.getLocalHost();    String hostName = ip1.getHostName(); //返回本机名字    String hostAddress = ip1.getHostAddress();//返回本机地址    System.out.println(hostName);    System.out.println(hostAddress);    InetAddress ip2 = InetAddress.getByName(&quot;www.moussemou.cn&quot;);//获取指定ip或者域名的ip地址对象    System.out.println(ip2.getHostName());    System.out.println(ip2.getHostAddress());    boolean reachable = ip2.isReachable(7000); //判断本机是否与该ip对象联通， 7秒后还没连接则返回失败    System.out.println(reachable);&#39;&#39;&#39;</code></pre><h2 id="简单的实现UDP协议的例子"><a href="#简单的实现UDP协议的例子" class="headerlink" title="简单的实现UDP协议的例子"></a>简单的实现UDP协议的例子</h2><pre><code>&#39;&#39;&#39;客户端（发送端）    DatagramSocket da1 = new DatagramSocket();   //创建客户端对象    DatagramPacket pa1 = new DatagramPacket(&quot;呵呵哒&quot;.getBytes(), //要发送的数据, 以字节数组形式            &quot;呵呵哒&quot;.getBytes().length,          //要发送的数据的长度，            InetAddress.getLocalHost(),          //要发送给的ip地址， 这里是本机， 如要发送其他地址则用InetAddress.getByname(&quot;IP地址&quot;)            6666);                    //要发送的端口号    da1.send(pa1);    System.out.println(&quot;客户端发送完毕！&quot;);    da1.close();  //用玩要关闭客户端对象， 否则会占用网卡资源&#39;&#39;&#39;注意： 要先启动服务端（接收端）， &#39;&#39;&#39;服务端（接收端）    System.out.println(&quot;服务端， 启动！&quot;);    DatagramSocket d1 = new DatagramSocket(6666);  //指定端口号    byte[] bytes = new byte[1024 * 64];  //一个包不会超过64kb    DatagramPacket p1 = new DatagramPacket(bytes, bytes.length);//指定需要接受的数据包    d1.receive(p1);  //服务端开始接受数据， 在接收到数据之前， 程序会在此阻塞    int length = p1.getLength();  //接受数据的长度    String strs = new String(bytes, 0, length); //接受多少倒多少， 不会造成资源浪费    System.out.println(strs);  //输出客户端内容    d1.close();  //用完释放资源&#39;&#39;&#39;</code></pre><h2 id="简单的实现TCP协议的例子"><a href="#简单的实现TCP协议的例子" class="headerlink" title="简单的实现TCP协议的例子"></a>简单的实现TCP协议的例子</h2><pre><code>&#39;&#39;&#39;输出端    Socket socket = new Socket(&quot;127.0.0.1&quot;, 8888); //建立客户端对象    OutputStream outputStream = socket.getOutputStream();  //输出流    DataOutputStream dataOutputStream = new DataOutputStream(outputStream);  //包装成数据输出流， 提升效率    dataOutputStream.writeUTF(&quot;呵呵哒&quot;);  //用writeUTF方法直接写字符串    dataOutputStream.close();   //关闭流管道    socket.close();    //关闭客户端&#39;&#39;&#39;&#39;&#39;&#39;输入端    ServerSocket serverSocket = new ServerSocket(8888);  //创建接收的服务端， 指定端口号    Socket accept = serverSocket.accept();   //accept方法等待接收    InputStream inputStream = accept.getInputStream();  //得到输入流    DataInputStream dataInputStream = new DataInputStream(inputStream); //创建数据输入流    String s = dataInputStream.readUTF();   //一一对应， 与输出端相对应 用readutf读取数据    System.out.println(s);   //打印数据    dataInputStream.close();  //关闭流    accept.close();   //释放资源&#39;&#39;&#39;</code></pre><h2 id="简单的实现TCP协议的例子，-实现多发多收"><a href="#简单的实现TCP协议的例子，-实现多发多收" class="headerlink" title="简单的实现TCP协议的例子， 实现多发多收"></a>简单的实现TCP协议的例子， 实现多发多收</h2><pre><code>&#39;&#39;&#39;客户端    Socket socket = new Socket(&quot;127.0.0.1&quot;, 8888); //建立客户端对象    OutputStream outputStream = socket.getOutputStream();  //输出流    DataOutputStream dataOutputStream = new DataOutputStream(outputStream);  //包装成数据输出流， 提升效率    Scanner sc = new Scanner(System.in);    while (true) &#123;        System.out.println(&quot;请说：&quot;);        String s = sc.nextLine();        if(s.equals(&quot;exit&quot;))&#123;            System.out.println(&quot;客户端关闭！&quot;);            dataOutputStream.close();            socket.close();            break;        &#125;        dataOutputStream.writeUTF(s);  //用writeUTF方法直接写字符串        dataOutputStream.flush();  //确保数据写出去    &#125;&#39;&#39;&#39;&#39;&#39;&#39;服务端    ServerSocket serverSocket = new ServerSocket(8888);  //创建接收的服务端， 指定端口号    System.out.println(&quot;服务端启动！&quot;);    while (true)&#123;        Socket accept = serverSocket.accept();   //accept方法等待接收        System.out.println(&quot;有人上线了！&quot; + accept.getRemoteSocketAddress());        new ServerThreadTest(accept).start();    &#125;&#39;&#39;&#39;&#39;&#39;&#39;线程类public class ServerThreadTest extends Thread&#123;private Socket socket;public ServerThreadTest(Socket socket)&#123;    this.socket = socket;&#125;@Overridepublic void run() &#123;    try &#123;        InputStream inputStream = socket.getInputStream();        DataInputStream dataInputStream = new DataInputStream(inputStream);        while (true) &#123;            try &#123;                String s = dataInputStream.readUTF();                System.out.println(s);            &#125; catch (IOException e) &#123;                System.out.println(&quot;有人下线了！&quot; + socket.getRemoteSocketAddress());                dataInputStream.close();                socket.close();                break;            &#125;        &#125;    &#125; catch (Exception e) &#123;        e.printStackTrace();        &#125;    &#125;&#125;&#39;&#39;&#39;</code></pre><h2 id="简单实现群聊例子"><a href="#简单实现群聊例子" class="headerlink" title="简单实现群聊例子"></a>简单实现群聊例子</h2><pre><code>分为服务端和客户端， 用到两个独立线程&#39;&#39;&#39;客户端    Socket socket = new Socket(&quot;127.0.0.1&quot;, 8888); //建立客户端对象    new SocktThreadTest(socket).start();    OutputStream outputStream = socket.getOutputStream();  //输出流    DataOutputStream dataOutputStream = new DataOutputStream(outputStream);  //包装成数据输出流， 提升效率    Scanner sc = new Scanner(System.in);    while (true) &#123;//            System.out.println(&quot;请说：&quot;);        String s = sc.nextLine();        if(s.equals(&quot;exit&quot;))&#123;            System.out.println(&quot;客户端关闭！&quot;);            dataOutputStream.close();            socket.close();            break;        &#125;        dataOutputStream.writeUTF(s);  //用writeUTF方法直接写字符串        dataOutputStream.flush();  //确保数据写出去    &#125;&#39;&#39;&#39;&#39;&#39;&#39;客户端接受线程    private Socket socket;public SocktThreadTest(Socket socket)&#123;    this.socket = socket;&#125;@Overridepublic void run() &#123;    try &#123;        InputStream inputStream = socket.getInputStream();        DataInputStream dataInputStream = new DataInputStream(inputStream);        while (true) &#123;            try &#123;                String s = dataInputStream.readUTF();                System.out.println(Thread.currentThread().getName()+&quot;: &quot;+s);            &#125; catch (Exception e) &#123;                System.out.println(&quot;自己下线了！&quot; + socket.getRemoteSocketAddress());                dataInputStream.close();                socket.close();                break;            &#125;        &#125;    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#125;&#39;&#39;&#39;&#39;&#39;&#39;服务端static List&lt;Socket&gt; sockets = new ArrayList&lt;&gt;();public static void main(String[] args) throws Exception&#123;    ServerSocket serverSocket = new ServerSocket(8888);  //创建接收的服务端， 指定端口号    System.out.println(&quot;服务端启动！&quot;);    while (true)&#123;        Socket accept = serverSocket.accept();   //accept方法等待接收        sockets.add(accept);        System.out.println(&quot;有人上线了！&quot; + accept.getRemoteSocketAddress());        new ServerThreadTest(accept).start();    &#125;&#125;&#39;&#39;&#39;&#39;&#39;&#39;服务端接受线程    private Socket socket;public ServerThreadTest(Socket socket)&#123;    this.socket = socket;&#125;@Overridepublic void run() &#123;    try &#123;        InputStream inputStream = socket.getInputStream();        DataInputStream dataInputStream = new DataInputStream(inputStream);        while (true) &#123;            try &#123;                String s = dataInputStream.readUTF();//                    TCPServerTest.sockets.add(socket);                System.out.println(Thread.currentThread().getName()+&quot;: &quot;+s);                tranSon(s);            &#125; catch (Exception e) &#123;                System.out.println(&quot;有人下线了！&quot; + socket.getRemoteSocketAddress());                dataInputStream.close();                socket.close();                TCPServerTest.sockets.remove(socket);                break;            &#125;        &#125;    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#39;&#39;&#39;</code></pre><h2 id="利用服务端传输数据到浏览器"><a href="#利用服务端传输数据到浏览器" class="headerlink" title="利用服务端传输数据到浏览器"></a>利用服务端传输数据到浏览器</h2><pre><code>&#39;&#39;&#39;服务端    System.out.println(&quot;服务端启动！&quot;);    ServerSocket socket = new ServerSocket(8080);    while (true) &#123;        Socket accept = socket.accept();        System.out.println(&quot;有人上线了！&quot; +accept.getRemoteSocketAddress());        new ServerTehread3(accept).start();    &#125;&#39;&#39;&#39;&#39;&#39;&#39;服务端线程private Socket socket;public ServerTehread3(Socket socket)&#123;    this.socket = socket;&#125;@Overridepublic void run()&#123;    try &#123;        OutputStream outputStream = socket.getOutputStream();        PrintStream p1 = new PrintStream(outputStream);        p1.println(&quot;HTTP/1.1 200 OK&quot;);        p1.println(&quot;Content-Type:text/html;charset=UTF-8&quot;);        p1.println();        p1.println(&quot;呵呵哒&quot;);        p1.close();        socket.close();    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#125;&#39;&#39;&#39;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/2023/11/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/11/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="继承Thread类重写run方法"><a href="#继承Thread类重写run方法" class="headerlink" title="继承Thread类重写run方法"></a>继承Thread类重写run方法</h2><pre><code>&#39;&#39;&#39;public class ThreadTest &#123;public static void main(String[] args) &#123;    Thread t1 = new MyThread();    t1.start();    //一定要在主线程之前启动， 否则不是并发                    //一定要用start方法， 否则只是单纯的调用方法    for (int i = 0; i &lt; 50; i++) &#123;        System.out.println(&quot;主线程启动！&quot;);    &#125;&#125;public static class MyThread extends Thread&#123;    @Override    public void run() &#123;        for (int i = 0; i &lt; 50; i++) &#123;            System.out.println(&quot;副线程启动！&quot;);        &#125;    &#125;&#125;-------------------------------------------------------------------------------public class ThreadTest &#123;public static void main(String[] args) &#123;    Thread t1 = new MyThread();    t1.setName(&quot;1号线程&quot;);   //设置线程名称    t1.start();//        System.out.println(t1.getName());        Thread t2 = new MyThread();        t2.setName(&quot;2号线程&quot;);        t2.start();//        System.out.println(t2.getName());        Thread m = Thread.currentThread();   //获取当前线程对象//        System.out.println(m.getName());    for (int i = 0; i &lt; 50; i++) &#123;        System.out.println(m.getName()+&quot;: 主线程启动！&quot;);    &#125;&#125;public static class MyThread extends Thread&#123;    @Override    public void run() &#123;        Thread thread = Thread.currentThread();        for (int i = 0; i &lt; 50; i++) &#123;            System.out.println(thread.getName()+&quot;: 副线程启动！&quot;);        &#125;    &#125;&#125;&#125;&#39;&#39;&#39;</code></pre><h2 id="测试类实现Runnable接口"><a href="#测试类实现Runnable接口" class="headerlink" title="测试类实现Runnable接口"></a>测试类实现Runnable接口</h2><pre><code>&#39;&#39;&#39;public class RunnableTest &#123;    public static void main(String[] args) &#123;    Runnable r = new MyRunnable();    new Thread(r).start();    for (int i = 0; i &lt; 100; i++) &#123;        System.out.println(&quot;主线程启动！！！&quot;);    &#125;    new Thread(new MyRunnable()&#123;        @Override        public void run() &#123;            System.out.println(&quot;hehda&quot;);        &#125;    &#125;).start();    new Thread(new Runnable() &#123;        @Override        public void run() &#123;            System.out.println(&quot;hehda&quot;);         //匿名内部类方式创建线程        &#125;                                       //这种方式更加方便    &#125;).start();    new Thread(()-&gt; System.out.println(&quot;hehda&quot;)).start();  //lambda简化&#125;public static class MyRunnable implements Runnable&#123;    @Override    public void run() &#123;        for (int i = 0; i &lt; 100; i++) &#123;            System.out.println(&quot;子线程启动！！&quot;);        &#125;    &#125;&#125;&#125;&#39;&#39;&#39;</code></pre><h2 id="实现Callable类获取返回值"><a href="#实现Callable类获取返回值" class="headerlink" title="实现Callable类获取返回值"></a>实现Callable类获取返回值</h2><pre><code>&#39;&#39;&#39;public class ClaalebleTest &#123;public static void main(String[] args) throws Exception &#123;    Callable&lt;String&gt; c1 = new MyCallble(100);    FutureTask&lt;String&gt; f1 = new FutureTask&lt;&gt;(c1);  //用futuretask类包装    new Thread(f1).start();    //程序执行到这里， 主线程会暂停， 等待上面线程执行完毕    System.out.println(f1.get());&#125;public static class MyCallble implements Callable&lt;String&gt;&#123;   //需指定泛型数据类型， 即返回的数据类型    private int n;    public MyCallble(int n) &#123;        this.n = n;    &#125;    @Override    public String call() throws Exception &#123;        int sum = 0;        for (int i = 1; i &lt;= n; i++) &#123;            sum += i;        &#125;        return &quot;1到&quot; + n + &quot;的和为：&quot; + sum;    &#125; &#125;&#125;&#39;&#39;&#39;</code></pre><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><pre><code>&#39;&#39;&#39;/*      public ThreadPoolExecutor(int corePoolSize,    int maximumPoolSize,    long keepAliveTime,    TimeUnit unit,    BlockingQueue&lt;Runnable&gt; workQueue,    ThreadFactory threadFactory,    RejectedExecutionHandler handler)*/    ExecutorService pool = new ThreadPoolExecutor(3, 5, 8,  //核心线程数， 总线程数， 指定时间单位数            TimeUnit.SECONDS,          //指定时间单位            new ArrayBlockingQueue&lt;&gt;(4), //队列中数量            Executors.defaultThreadFactory(),  //默认线程池            new ThreadPoolExecutor.AbortPolicy());  //任务的拒接策略    pool.execute(new myRunnable2());    pool.execute(new myRunnable2());    pool.execute(new myRunnable2());  //三个核心线程在忙    pool.execute(new myRunnable2());    pool.execute(new myRunnable2());    pool.execute(new myRunnable2());    pool.execute(new myRunnable2());    pool.execute(new myRunnable2());  //队列已满， 此时创建临时线程    pool.execute(new myRunnable2());  //临时线程有两个    pool.execute(new myRunnable2());  //所有位置已占满， 开始拒接接收任务    pool.shutdown();  //等待所有线程结束关闭线程池//        pool.shutdownNow();  //立即关闭线程池， 无论线程是否执行完毕， 返回未完成的线程任务&#125;static class myRunnable2 implements Runnable&#123;    @Override    public void run() &#123;        System.out.println(Thread.currentThread().getName()+&quot;执行了！&quot;);        try &#123;            Thread.sleep(3000);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    &#125;&#125;&#39;&#39;&#39;&#39;&#39;&#39;public class ThreadPoolTest2 &#123;public static void main(String[] args) &#123;//        ThreadPoolExecutor pool = new ThreadPoolExecutor(3, 5, 8,//                TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(4),//                Executors.defaultThreadFactory(),//                new ThreadPoolExecutor.AbortPolicy());    ExecutorService pool = Executors.newFixedThreadPool(3);  //通过Exeuctors类创建一个线程池    Future&lt;String&gt; f1 = pool.submit(new MyCallble2(100));    Future&lt;String&gt; f2 = pool.submit(new MyCallble2(200));    Future&lt;String&gt; f3 = pool.submit(new MyCallble2(300));    Future&lt;String&gt; f4 = pool.submit(new MyCallble2(400));    try &#123;        System.out.println(f1.get());        System.out.println(f2.get());        System.out.println(f3.get());        System.out.println(f4.get());    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;finally &#123;        pool.shutdown();    &#125;&#125;static class MyCallble2 implements Callable&lt;String&gt; &#123;    int n;    int sum = 0;    public MyCallble2(int n) &#123;        this.n = n;    &#125;    @Override    public String call() throws Exception &#123;        for (int i = 0; i &lt;= n; i++) &#123;            sum+=i;        &#125;        return Thread.currentThread().getName()+&quot;求出了1到&quot;+n+&quot;的和为&quot; +sum;        &#125;    &#125;&#125;&#39;&#39;&#39;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>特殊文件、日志</title>
      <link href="/2023/11/01/%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E3%80%81%E6%97%A5%E5%BF%97/"/>
      <url>/2023/11/01/%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E3%80%81%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h2 id="Properties后缀文件"><a href="#Properties后缀文件" class="headerlink" title="Properties后缀文件"></a>Properties后缀文件</h2><pre><code>&#39;&#39;&#39;    Properties p = new Properties();    p.load(new FileReader(&quot;Test_1028_mousse\\src\\UserTest.properties&quot;)); //读出目标数据    System.out.println(p.getProperty(&quot;name&quot;));  //根据键读取值    System.out.println(p.getProperty(&quot;age&quot;));    System.out.println(p.getProperty(&quot;score&quot;));    Set&lt;String&gt; strs = p.stringPropertyNames();    for (String str : strs) &#123;        System.out.println(str+&quot;----&quot;+p.getProperty(str));  //遍历键值对    &#125;    p.forEach((k, v)-&gt; &#123;        System.out.println(k +&quot;--&quot;+v);   //遍历键值对    &#125;);&#39;&#39;&#39;&#39;&#39;&#39;    //写进属性    Properties p = new Properties();    p.setProperty(&quot;name&quot;, &quot;呵呵哒&quot;);    p.setProperty(&quot;age&quot;, &quot;12&quot;);    p.setProperty(&quot;score&quot;, &quot;97&quot;);    p.store(new FileWriter(&quot;Test_1028_mousse\\src\\UserTest2.properties&quot;), &quot;这里必须写注释&quot;);&#39;&#39;&#39;</code></pre><h2 id="dom4j框架的使用"><a href="#dom4j框架的使用" class="headerlink" title="dom4j框架的使用"></a>dom4j框架的使用</h2><pre><code>    &#39;&#39;&#39;    SAXReader saxReader = new SAXReader();    Document r = saxReader.read(&quot;Test_1028_mousse\\hehee.xml&quot;);    Element root = r.getRootElement();  //从文档解析xml的全部数据    System.out.println(root.getName()); //读取xml的根标签    List&lt;Element&gt; elements = root.elements();  //获取root下的全部一级标签    //        List&lt;Element&gt; u = root.elements(&quot;user&quot;); //获取指定的全部目录    for (Element element : elements) &#123;        System.out.println(element.getName());    &#125;    System.out.println(root.element(&quot;people&quot;).getText());  //获取目录下指定的一级标签内容    System.out.println(root.element(&quot;user&quot;).elementText(&quot;age&quot;)); //这样写默认获取第一个user目录， elementText获取目录内容    Element user = root.element(&quot;user&quot;);    Attribute id = user.attribute(&quot;id&quot;);    System.out.println(id.getName());   //获取id名字    System.out.println(id.getValue());  //获取id的值    System.out.println(user.attributeValue(&quot;id&quot;));   //同上。 获取id的值    List&lt;Attribute&gt; attributes = user.attributes();    for (Attribute attribute : attributes) &#123;        System.out.println(attribute.getName()+ &quot;----&quot;+attribute.getValue());  //获取第一个标签全部内容    &#125;    System.out.println(user.elementText(&quot;name&quot;));   //获取个标签下的值    System.out.println(user.elementText(&quot;age&quot;));       System.out.println(user.elementText(&quot;score&quot;));    &#39;&#39;&#39;</code></pre><h2 id="LogBack日志"><a href="#LogBack日志" class="headerlink" title="LogBack日志"></a>LogBack日志</h2><pre><code>&#39;&#39;&#39;public static final Logger LOGGER = LoggerFactory.getLogger(&quot;LogBackTest&quot;);        try &#123;        LOGGER.info(&quot;乘法开始执行！&quot;);        multiply(1, 2);        LOGGER.info(&quot;乘法执行成功！&quot;);    &#125; catch (Exception e) &#123;        LOGGER.error(&quot;乘法执行失败！&quot;);    &#125;&#125;public static void multiply(int i, int j)&#123;    LOGGER.debug(&quot;乘数：&quot; + j);    LOGGER.debug(&quot;被乘数&quot; + i);//        System.out.println(i*j);    LOGGER.info(&quot;答案是：&quot; + i*j);&#125;&#39;&#39;&#39;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IO流的使用</title>
      <link href="/2023/10/30/IO%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/10/30/IO%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="FileInputStream类"><a href="#FileInputStream类" class="headerlink" title="FileInputStream类"></a>FileInputStream类</h2><pre><code>&#39;&#39;&#39;//        File f1 = new File(&quot;D:\\LearrnMoreJavaTest\\Test_1028_mousse\\src\\IOpackage\\heheda.txt&quot;);//        f1.mkdirs();        FileInputStream f1 = new FileInputStream(&quot;D:\\LearrnMoreJavaTest\\Test_1028_mousse\\heheda.txt&quot;); //获取源文件//        System.out.println(f1.read());  //读取第一个字节//        System.out.println(f1.read());  //读取第二个字节//        System.out.println(f1.read());  //读取第三个字节//        System.out.println(f1.read());  //读取第四个字节    int b;    while ((b = f1.read()) != -1)&#123;   //若读取到尽头， 则会返回负1        System.out.print(b);    &#125;    f1.close();   //流使用完必须关闭， 释放系统资源&#39;&#39;&#39;&#39;&#39;&#39;        FileInputStream f1 = new FileInputStream(&quot;Test_1028_mousse\\heheda.txt&quot;);        //        byte[] b1 = new byte[3];  //建立一个字节数组， 用以存放每次读取的字节， 数量根据要读取的字符决定        //        int len = f1.read(b1);  //返回当次读取的字节数量， 此时b1存储三个字节        //        String s = new String(b1); //返回当前读取的内容        //        System.out.println(len);        //        System.out.println(s);        //        int len2 = f1.read(b1);        //        System.out.println(new String(b1));        //        int len3 = f1.read(b1);        //        System.out.println(new String(b1));        //        //        int len4 = f1.read(b1);        //        System.out.println(new String(b1, 0, len4)); //从0开始读写， 到读取字节的数量。 读多少就倒多少               //循环输出          //        int len;        //        byte [] b = new byte[3];        //        while ((len = f1.read(b) ) != -1 )&#123;        //            System.out.print(new String(b, 0, len));  //读多少倒多少        //        &#125;        //        File file1 = new File(&quot;Test_1028_mousse\\heheda.txt&quot;);        //        long length = file1.length();        //        byte[] b = new byte[(int) length];    //一次读完全部内容        //        int read = f1.read(b);        //        System.out.println(new String(b));        f1.close();&#39;&#39;&#39;</code></pre><h2 id="FileOutputStream类、"><a href="#FileOutputStream类、" class="headerlink" title="FileOutputStream类、"></a>FileOutputStream类、</h2><pre><code>&#39;&#39;&#39;    OutputStream f1 = new FileOutputStream(&quot;Test_1028_mousse/呵呵哒.txt&quot;);  //这是覆盖管道， 会覆盖原来的数据    f1.write(97);    f1.write(&#39;h&#39;);    byte[] b = &quot;呵呵哒呵呵哒呵呵哒&quot;.getBytes();   //getBytes方法将字符串拆分返回字符数组形式    f1.write(b);    f1.close();    OutputStream f2 = new FileOutputStream(&quot;Test_1028_mousse/呵呵哒呵呵哒.txt&quot;, true); //这是追加管道， 不会覆盖原来的数据    byte[] b2 = &quot;呵呵哒呵呵哒呵呵&quot;.getBytes();    f2.write(b2);    f2.write(&quot;\r\n&quot;.getBytes());  //\n换行不一定兼容全部平台， \r\n兼容全部平台    f2.write(b2);    f2.close();&#125;&#39;&#39;&#39;&#39;&#39;&#39;//复制案例    InputStream f1 = new FileInputStream(&quot;C:\\Users\\24084\\Desktop\\娱乐\\FuX.jpg&quot;);    OutputStream f2 = new FileOutputStream(&quot;C:\\Users\\24084\\Desktop\\娱乐\\FuXing.jpg&quot;);    int len;    byte[] b = new byte[1024];    while ((len = f1.read(b))!= -1)&#123;        f2.write(b, 0, len);    &#125;      f2.close();                    //先关闭后创建的流    f1.close();                    //再关闭前创建的流    System.out.println(&quot;复制完成&quot;);&#39;&#39;&#39;下面是规范的写法：&#39;&#39;&#39;    InputStream f1 = null;    OutputStream f2 = null;    try &#123;        f1 = new FileInputStream(&quot;C:\\Users\\24084\\Desktop\\娱乐\\FuX.jpg&quot;);        f2 = new FileOutputStream(&quot;C:\\Users\\24084\\Desktop\\娱乐\\FuXingCopy2.jpg&quot;);        int len;        byte[] b = new byte[1024];        while ((len = f1.read(b)) != -1) &#123;            f2.write(b, 0, len);        &#125;    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125; finally &#123;        if (f2 != null) &#123;            try &#123;                f2.close();                    //先关闭后创建的流            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        if (f1 != null) &#123;            try &#123;                f1.close();                    //再关闭前创建的流                System.out.println(&quot;复制完成&quot;);            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#39;&#39;&#39;&#39;&#39;&#39; jdk7后的写法， try()括号里写流， 会自动释放， 可以省去finally        try(            InputStream f1 = new FileInputStream(&quot;C:\\Users\\24084\\Desktop\\娱乐\\FuX.jpg&quot;);            OutputStream f2 =  new FileOutputStream(&quot;C:\\Users\\24084\\Desktop\\娱乐\\Kafka&amp;Setelite.jpg&quot;);        ) &#123;            int len;            byte[] b = new byte[1024];            while ((len = f1.read(b))!= -1)&#123;                f2.write(b, 0, len);            &#125;        System.out.println(&quot;复制成功&quot;);    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;&#39;&#39;&#39;</code></pre><h2 id="FileReader字符流类的使用"><a href="#FileReader字符流类的使用" class="headerlink" title="FileReader字符流类的使用"></a>FileReader字符流类的使用</h2><pre><code>&#39;&#39;&#39;        try(Reader f1 = new FileReader(&quot;Test_1028_mousse\\呵呵哒呵呵哒.txt&quot;);) &#123;        int c; //记录每次读取的字符序号//            while ((c = f1.read())!= -1)&#123;//                System.out.print((char)c);    //把每次读取的字符序号转换成字符类型//            &#125;        char[] b = new char[3];  //创建字符串数组        while ((c = f1.read(b)) != -1) &#123;            System.out.print(new String(b, 0, c));   //写多少倒多少        &#125;    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#39;&#39;&#39;</code></pre><h2 id="FileWriter字符流类的使用"><a href="#FileWriter字符流类的使用" class="headerlink" title="FileWriter字符流类的使用"></a>FileWriter字符流类的使用</h2><pre><code>&#39;&#39;&#39;//        try(Writer f1 = new FileWriter(&quot;Test_1028_mousse\\呵呵哒o.txt&quot;);) &#123;//            f1.write(&#39;h&#39;);  //可以写一个字符////            f1.write(&quot;呵呵哒&quot;);//可以写字符串//            char[] c = new char[]&#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;;//            f1.write(c);  //可以写字符数组//            f1.write(c, 0 ,1);  //可以根据需求写字符数组， 从0个到1， 写a和b//            f1.write(&quot;\r\n&quot;);   //可直接写换行符//            f1.write(&quot;呵呵哒&quot;, 0, 1); //字符串同理////        &#125; catch (IOException e) &#123;//            e.printStackTrace();//        &#125;    Writer f1 = new FileWriter(&quot;Test_1028_mousse\\\\呵呵哒2.txt&quot;);    f1.write(&quot;呵呵哒&quot;);    f1.write(&quot;呵呵哒&quot;);    f1.write(&quot;呵呵哒&quot;);    f1.flush();   //字符流使用完毕必须刷新或者关闭， 否则不会写出数据    //刷新后的流还可以继续使用    f1.write(&quot;\r\n&quot;);    f1.write(&quot;、、、、呵呵哒&quot;);    f1.flush();   //写完之后必须刷新， 或者关闭    f1.close();   //关闭流包含刷新流， 关闭后不能再使用流了。&#125;&#39;&#39;&#39;</code></pre><h2 id="字节缓冲输入输出流"><a href="#字节缓冲输入输出流" class="headerlink" title="字节缓冲输入输出流"></a>字节缓冲输入输出流</h2><pre><code>&#39;&#39;&#39;    try (        InputStream f1 = new FileInputStream(&quot;Test_1028_mousse\\呵呵哒.txt&quot;);        InputStream f1h = new BufferedInputStream(f1);   //字节输入缓冲流        OutputStream f2 = new FileOutputStream(&quot;Test_1028_mousse\\呵呵哒3.txt&quot;);        OutputStream f2h = new BufferedOutputStream(f2);)&#123;        int len;        byte [] c=  new byte[1024];        while ((len = f1h.read(c))!=-1)&#123;            f2h.write(c, 0, len);        &#125;        System.out.println(&quot;复制完成&quot;);    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#39;&#39;&#39;</code></pre><h2 id="字符缓冲输入输出流"><a href="#字符缓冲输入输出流" class="headerlink" title="字符缓冲输入输出流"></a>字符缓冲输入输出流</h2><pre><code>&#39;&#39;&#39;        try ( FileReader f1 = new FileReader(&quot;Test_1028_mousse\\呵呵哒呵呵哒.txt&quot;);          BufferedReader b1 = new BufferedReader(f1);)&#123;//            System.out.println(b1.readLine());   //直接读取一行//            System.out.println(b1.readLine());//            System.out.println(b1.readLine());        String str;        while ((str = b1.readLine())!= null)&#123;            System.out.println(str);         //有多少行读多少行        &#125;    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#39;&#39;&#39;</code></pre><h2 id="字符输入转换流"><a href="#字符输入转换流" class="headerlink" title="字符输入转换流"></a>字符输入转换流</h2><pre><code>InputStreamReader类实现， 输出转换流同理。&#39;&#39;&#39;    try (InputStreamReader f1 = new InputStreamReader(new FileInputStream(&quot;D:\\LearrnMoreJavaTest\\Test_1028_mousse\\呵呵哒呵呵哒.txt&quot;), &quot;UTF-8&quot;);         BufferedReader b1 = new BufferedReader(f1);    )&#123;        String str;        while ((str = b1.readLine())!= null)&#123;            System.out.println(str);        &#125;    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#39;&#39;&#39;</code></pre><h2 id="字节字符打印流"><a href="#字节字符打印流" class="headerlink" title="字节字符打印流"></a>字节字符打印流</h2><p>printStream:<br>printWriter同理， 主要用打印功能</p><pre><code>&#39;&#39;&#39;          try (PrintStream p1 = new PrintStream(&quot;Test_1028_mousse\\呵呵哒呵呵哒2.txt&quot;);)&#123;        p1.println(&quot;呵呵哒&quot;);   //可以直接打印出去        p1.println(&quot;呵呵哒&quot;);        p1.println(&quot;呵呵哒&quot;);        p1.write(97);    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#125;&#39;&#39;&#39;</code></pre><h2 id="数据输入输出流"><a href="#数据输入输出流" class="headerlink" title="数据输入输出流"></a>数据输入输出流</h2><pre><code>&#39;&#39;&#39;  DataOutputStream: 写出数据        try (DataOutputStream d1 = new DataOutputStream(new FileOutputStream(&quot;Test_1028_mousse\\呵呵哒呵呵哒3.txt&quot;));//             DataInputStream d2 = new DataInputStream(new FileInputStream(&quot;Test_1028_mousse\\呵呵哒呵呵哒3.txt&quot;));    )&#123;        d1.writeInt(1);  //按指定类型写数据        d1.writeInt(2);        d1.writeInt(3);        d1.writeUTF(&quot;呵呵哒&quot;);        d1.writeUTF(&quot;呵呵哒&quot;);        d1.writeDouble(1.1);    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#39;&#39;&#39;&#39;&#39;&#39;DataInputStream: 读入数据        try (DataInputStream d1 = new DataInputStream(new FileInputStream(&quot;Test_1028_mousse\\呵呵哒呵呵哒3.txt&quot;));)&#123;        System.out.println(d1.readInt());   //必须按写的顺序读， 并且指定类型        System.out.println(d1.readInt());        System.out.println(d1.readInt());        System.out.println(d1.readUTF());//            System.out.println(d1.readDouble());        System.out.println(d1.readUTF());        System.out.println(d1.readDouble());    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#39;&#39;&#39;</code></pre><h2 id="对象输入输出流"><a href="#对象输入输出流" class="headerlink" title="对象输入输出流"></a>对象输入输出流</h2><pre><code>&#39;&#39;&#39;    //ObjectOutputStream:  写入对象数据    try(ObjectOutputStream o1 = new ObjectOutputStream(new FileOutputStream(&quot;Test_1028_mousse\\呵呵哒呵呵哒4.txt&quot;));) &#123;        Users u1 = new Users(&quot;呵呵哒&quot;, 12);        o1.writeObject(u1);        System.out.println(&quot;对象序列化成功！&quot;);    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#39;&#39;&#39;&#39;&#39;&#39;ObjectInputStream:读取对象数据        try (ObjectInputStream o1 = new ObjectInputStream(new FileInputStream(&quot;Test_1028_mousse\\呵呵哒呵呵哒4.txt&quot;));)&#123;        Users u = (Users)o1.readObject();        System.out.println(u.getName());        System.out.println(u.getAge());    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#39;&#39;&#39;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>File类的使用</title>
      <link href="/2023/10/29/File%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/10/29/File%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="File对象一些常用方法"><a href="#File对象一些常用方法" class="headerlink" title="File对象一些常用方法"></a>File对象一些常用方法</h2><pre><code>&#39;&#39;&#39;    File f1 = new File(&quot;C:\\Users\\24084\\Desktop\\学习笔记\\MySQL笔记.txt&quot;);  //获取文件对象    File f2 = new File(&quot;C:/Users/24084/Desktop/学习笔记/MySQL笔记.txt&quot;);  //用正斜杠也可。 只需一个/    File f3 = new File(&quot;C:&quot; + File.separator + &quot;Users&quot;+File.separator+ &quot;24084&quot;+            File.separator+&quot;Desktop&quot;+File.separator+&quot;学习笔记&quot;+File.separator+&quot;MySQL笔记.txt&quot;);  //也可用file类自带的常量分割， 分隔符由系统决定    System.out.println(f1.length());    //返回文件的字节个数    System.out.println(f2.length());    //返回文件的字节个数    System.out.println(f3.length());    //返回文件的字节个数    File f4 = new File(&quot;C:/Users/24084/Desktop/学习笔记&quot;);  //也可获取文件夹对象    System.out.println(f4.length());          //获取文件夹本身的大小， 并不包括文件夹里所有的内容    System.out.println(f4.exists());  //判断文件或文件夹是否存在    File f5 = new File(&quot;D:/呵呵哒&quot;);   //可以指代不存在的文件    System.out.println(f5.exists());  //判断文件或文件夹是否存在    File f6 = new File(&quot;D:\\LearrnMoreJavaTest\\Test_1028_mousse\\src\\com\\fileeTest\\呵呵哒.txt&quot;);//获取包里的文件， 这里是绝对路径    File f7 = new File(&quot;Test_1028_mousse\\src\\com\\fileeTest\\呵呵哒.txt&quot;);//获取包里的文件， 这里是相对路径, 从包开始找， 也可从工程开始， 加上工程路径    System.out.println(f7.length());    System.out.println(f7.isFile());//判断该文件是否是文件    System.out.println(f7.isDirectory()); //判断该文件是否是文件夹    System.out.println(f4.isDirectory()); //判断该文件是否是文件夹    System.out.println(f7.getName());  //获取文件的名字， 包括后缀    System.out.println(f7.lastModified()); //获取文件的最后修改时间    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);    System.out.println(sdf.format(f7.lastModified()));  //解析后的时间    System.out.println(f7.getPath());  //获取文件对象时， 使用的路径    System.out.println(f7.getAbsolutePath());  //获取文件的绝对路径&#39;&#39;&#39;</code></pre><h2 id="File类对象创建和删除文件的方法"><a href="#File类对象创建和删除文件的方法" class="headerlink" title="File类对象创建和删除文件的方法"></a>File类对象创建和删除文件的方法</h2><pre><code>&#39;&#39;&#39;    File f1 = new File(&quot;D:\\LearrnMoreJavaTest\\Test_1028_mousse\\src\\com\\fileeTest\\呵呵哒2.txt&quot;);    try &#123;        System.out.println(f1.createNewFile());   //创建文件， 成功返回true, 反之false        System.out.println(f1.createNewFile());   //如果已经存在， 那么返回false， 不会再次创建    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;    File f2 = new File(&quot;D:\\LearrnMoreJavaTest\\Test_1028_mousse\\src\\com\\fileeTest\\呵呵哒文件夹&quot;);    System.out.println(f2.mkdir());  //创建文件夹，成功返回true, 否则返回false 这个方法只能创建一级文件夹    File f3 = new File(&quot;D:\\LearrnMoreJavaTest\\Test_1028_mousse\\src\\com\\fileeTest\\一级文件\\二级文件\\三级文件&quot;);    System.out.println(f3.mkdirs());  //创建文件夹， 这个方法可以创建多级文件夹    System.out.println(f2.delete());  //删除文件夹， 不能删除非空文件夹    System.out.println(f3.delete());    //删除最外的三级文件    File f4 = new File(&quot;D:\\LearrnMoreJavaTest\\Test_1028_mousse\\src\\com\\fileeTest&quot;);    String[] list = f4.list();    //获取当前文件夹目录下所有一级文件名称， 并返回字符串数组    System.out.println(Arrays.toString(list));    File[] listFiles = f4.listFiles();   //获取当前文件夹目录下所有一级文件， 并返回文件数组    for (File listFile : listFiles) &#123;        System.out.println(listFile.getAbsolutePath());    &#125;&#39;&#39;&#39;</code></pre><h2 id="File类搜索文件的方法"><a href="#File类搜索文件的方法" class="headerlink" title="File类搜索文件的方法"></a>File类搜索文件的方法</h2><pre><code>&#39;&#39;&#39;    public static void searchFile(File file, String FileName) &#123;    if (file == null || !file.exists() || file.isFile()) &#123;        return;    &#125;    File[] files = file.listFiles();    if (files != null &amp;&amp; files.length &gt; 0) &#123;        for (File f : files) &#123;            if (f.isFile()) &#123;                if (f.getName().contains(FileName)) &#123;                    System.out.println(&quot;找到了：&quot; + f.getAbsolutePath());                    // Runtime runtime = Runtime.getRuntime();                    // try &#123;                    // runtime.exec(f.getAbsolutePath());                    //  &#125; catch (IOException e) &#123;                    //   e.printStackTrace();                    //  &#125;                &#125;            &#125; else &#123;                searchFile(f, FileName);            &#125;        &#125;    &#125;&#125;&#39;&#39;&#39;</code></pre><h2 id="File类删除多级文件的方法"><a href="#File类删除多级文件的方法" class="headerlink" title="File类删除多级文件的方法"></a>File类删除多级文件的方法</h2><pre><code>&#39;&#39;&#39;    public static void deleteFile(File file)&#123;    if (file==null||!file.exists())&#123;        return;    &#125;    if (file.isFile())&#123;        file.delete();    &#125;    File[] files = file.listFiles();    if (files!=null) &#123;        for (File f : files) &#123;            if (f.isFile()) &#123;                f.delete();            &#125; else &#123;                deleteFile(f);            &#125;        &#125;    &#125;    file.delete();&#125;&#39;&#39;&#39;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>“集合类的使用”</title>
      <link href="/2023/10/22/%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/10/22/%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Collection类的一些常用方法"><a href="#Collection类的一些常用方法" class="headerlink" title="Collection类的一些常用方法"></a>Collection类的一些常用方法</h2><pre><code>&#39;&#39;&#39;        Collection&lt;String&gt; coll = new ArrayList&lt;&gt;();        coll.add(&quot;呵呵哒&quot;);        coll.clear(); //清空该集合所有元素        coll.isEmpty();//判断是否是空集合        coll.size();//获取集合大小        coll.contains(&quot;呵呵哒&quot;);//判断集合是否包含某个指定元素        coll.remove(&quot;呵呵哒&quot;);//删除集合某个指定元素        coll.toArray(); //把集合转换成数组。&#39;&#39;&#39;</code></pre><h2 id="iterator类迭代器的使用"><a href="#iterator类迭代器的使用" class="headerlink" title="iterator类迭代器的使用"></a>iterator类迭代器的使用</h2><pre><code>&#39;&#39;&#39;        Collection&lt;String&gt; coll2 = new ArrayList&lt;&gt;();        coll2.add(&quot;呵呵哒&quot;);        coll2.add(&quot;呵呵哒&quot;);        coll2.add(&quot;呵呵哒&quot;);        coll2.add(&quot;呵呵哒&quot;);        coll2.add(&quot;呵呵哒&quot;);        coll.addAll(coll2);        Iterator&lt;String&gt; iterator = coll.iterator();        while (iterator.hasNext())&#123; //判断当前指向元素是否存在            System.out.println(iterator.next());   //输出当前指向元素        &#125;&#39;&#39;&#39;</code></pre><h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><p>   增强for循环遍历集合， 就是迭代器遍历集合的简化写法</p><pre><code>&#39;&#39;&#39;        for(String str : coll)&#123;  //增强for循环， 用以遍历数组或集合 格式为：for(数据类型 变量名 : 需要遍历的数组或集合) 其中， 变量名为被遍历的其中每一个元素            System.out.println(str);        &#125;        int [] arr = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;;           for (int i : arr)&#123;          //增强for循环遍历数组   快捷键： arr.for            System.out.println(i);        &#125;&#39;&#39;&#39;</code></pre><h3 id="集合的forEach方法，-用lambda表达式实现集合的遍历"><a href="#集合的forEach方法，-用lambda表达式实现集合的遍历" class="headerlink" title="集合的forEach方法， 用lambda表达式实现集合的遍历"></a>集合的forEach方法， 用lambda表达式实现集合的遍历</h3><pre><code>&#39;&#39;&#39;        coll.forEach(new Consumer&lt;String&gt;() &#123;  //coll是集合， 上面代码的集合            @Override            public void accept(String s) &#123;    //匿名内部类实现                System.out.println(s);            &#125;        &#125;);        coll.forEach(s -&gt; System.out.println(s));  //一部部简化        coll.forEach(System.out::println);   //最终简化版本&#39;&#39;&#39;</code></pre><h3 id="List类集合的使用"><a href="#List类集合的使用" class="headerlink" title="List类集合的使用"></a>List类集合的使用</h3><pre><code>&#39;&#39;&#39;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(0, &quot;呵呵哒&quot;);  //在指定位置插入指定元素， 可以和插入队伍        list.remove(0);  //删除指定索引位置的元素, 并返回被删除的元素        list.add(&quot;呵呵哒&quot;);        list.add(&quot;呵呵哒&quot;);        list.add(&quot;呵呵哒&quot;);        list.add(&quot;呵呵哒&quot;);        list.set(0, &quot;呵呵哒&quot;);  //修改指定索引位置的元素， 并返回被修改的值        list.get(0); //返回指定索引位置的元素&#39;&#39;&#39;</code></pre><h3 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h3><pre><code>&#39;&#39;&#39;        //创建队列！    LinkedList&lt;String&gt; link = new LinkedList();    link.addLast(&quot;呵呵哒1&quot;);  //在末位置增加元素    link.addLast(&quot;呵呵哒2&quot;);    link.addLast(&quot;呵呵哒3&quot;);    link.addLast(&quot;呵呵哒4&quot;);    link.addLast(&quot;呵呵哒5&quot;);    System.out.println(link);    link.removeFirst();     //删除头部元素    link.removeFirst();    System.out.println(link);    link.removeLast();     //删除尾部元素    link.removeLast();    System.out.println(link);    //        for (String s : link) &#123;    //            System.out.println(s);    //        &#125;    //创建栈！    LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();    list.addFirst(&quot;呵呵哒1&quot;);   //从头部增加元素    list.addFirst(&quot;呵呵哒2&quot;);    list.push(&quot;呵呵哒3&quot;);    list.push(&quot;呵呵哒4&quot;);   //push方法和addfirst是一样的    list.push(&quot;呵呵哒5&quot;);    System.out.println(list);    //出栈    list.removeFirst();    list.removeFirst();    list.pop();    list.pop();   //pop方法和removefirst是一样的    System.out.println(list);&#39;&#39;&#39;</code></pre><h3 id="Set类的三个子类"><a href="#Set类的三个子类" class="headerlink" title="Set类的三个子类"></a>Set类的三个子类</h3><p>   其中， linkedhashset类是hashset类的子类</p><pre><code>&#39;&#39;&#39;    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();   //无序， 不重复， 无索引    set.add(111);    set.add(222);    set.add(333);    set.add(444);    set.add(444);    set.add(444);    set.add(444);    System.out.println(set);    Set&lt;Integer&gt; setlink = new LinkedHashSet&lt;&gt;();  //有序， 不重复， 无索引    setlink.add(111);    setlink.add(222);    setlink.add(333);    setlink.add(444);    setlink.add(444);    setlink.add(444);    setlink.add(444);    System.out.println(setlink);    Set&lt;Integer&gt; treesets = new TreeSet&lt;&gt;();    //默认有序， 不重复， 无索引    treesets.add(444);    treesets.add(222);    treesets.add(1111);    treesets.add(777);    treesets.add(777);    System.out.println(treesets);&#39;&#39;&#39;</code></pre><h2 id="MAP集合"><a href="#MAP集合" class="headerlink" title="MAP集合"></a>MAP集合</h2><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><pre><code>&#39;&#39;&#39;        maptest.put(1, &quot;呵呵哒&quot;);        maptest.put(2, &quot;呵呵哒&quot;);        maptest.put(3, &quot;呵呵哒&quot;);        maptest.put(4, &quot;呵呵哒&quot;);        maptest.put(8, &quot;呵呵哒&quot;);        maptest.put(null, null);        System.out.println(maptest);        System.out.println(maptest.size());  //获取集合的大小        maptest.clear();   //清空集合        maptest.isEmpty();  //判断集合是否为空        maptest.get(2);  //通过键值获取对应值        maptest.put(1, &quot;呵呵哒&quot;);        maptest.put(2, &quot;呵呵哒&quot;);        maptest.put(3, &quot;呵呵哒&quot;);        maptest.put(4, &quot;呵呵哒&quot;);        maptest.put(8, &quot;呵呵哒&quot;);        maptest.put(null, null);        maptest.remove(2);  //通过键值删除对应元素        maptest.containsKey(2);//判断是否包含某个键        maptest.containsValue(&quot;呵呵哒&quot;);//判断是否包含某个值        maptest.keySet();  //获取集合的全部键        maptest.values();  //获取集合的全部值        Map&lt;Integer, String&gt; maptest2 = new HashMap&lt;&gt;();        maptest2.putAll(maptest);//把map1的键全部倒入map2中, 重复的键会覆盖        System.out.println(maptest2);&#39;&#39;&#39;</code></pre><h4 id="map集合遍历方式"><a href="#map集合遍历方式" class="headerlink" title="map集合遍历方式"></a>map集合遍历方式</h4><p>‘’’</p><pre><code>    //遍历map集合    //1. 通过键找值    Set&lt;Integer&gt; integers = maptest.keySet();    for (Integer integer : integers) &#123;        String s = maptest.get(integer);        System.out.println(integer + &quot;-&quot; + s);    &#125;    //2. 通过entrySet方法遍历    Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entries = maptest.entrySet();    for (Map.Entry&lt;Integer, String&gt; entry : entries) &#123;        System.out.println(entry.getKey() +&quot;-&quot;+ entry.getValue() +&quot; &quot;);    &#125;    //3. 用lambda表达式遍历    maptest.forEach((k, v) -&gt; &#123;        System.out.println(k+&quot;-&quot;+v);    &#125;);</code></pre><p>‘’’</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>单例设计模式</title>
      <link href="/2023/10/14/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/10/14/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="单例设计模式创建的方法"><a href="#单例设计模式创建的方法" class="headerlink" title="单例设计模式创建的方法"></a>单例设计模式创建的方法</h1><ol><li><p>饿汉式单例： 拿对象时， 对象已经建立完成。</p><p> ‘’’java</p><pre><code> //2.定义一个类变量， 记住类的对象 private static A a = new A(); //1.私有构造器 private A()&#123; &#125; //3.定义一个类方法， 返回类的对象 public static A getA()&#123;     return a; &#125;</code></pre><p> ‘’’</p></li><li><p>懒汉式单例， 拿对象时， 才开始创建对象。<br> ‘’’java</p><pre><code> //2. 定义一个类变量， 用于存储对象 private static B b; //1. 把构造器私有 private B()&#123; &#125; //3. 定义一个方法， 只有在调用时才创建对象 public static B getInstance()&#123;     if (b == null)&#123;         b = new B();     &#125;     return b; &#125;</code></pre><p> ‘’’</p></li></ol><p>用这种模式创建的对象有且仅有一个</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>API常用类</title>
      <link href="/2023/10/07/API%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
      <url>/2023/10/07/API%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="char字符数组转换成String的一种方式"><a href="#char字符数组转换成String的一种方式" class="headerlink" title="char字符数组转换成String的一种方式"></a>char字符数组转换成String的一种方式</h2><pre><code>    &#39;&#39;&#39;java        char [] arr = new char[]&#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;;        String str = new String(arr);        System.out.println(str);    &#39;&#39;&#39;</code></pre><h2 id="String类常用的方法："><a href="#String类常用的方法：" class="headerlink" title="String类常用的方法："></a>String类常用的方法：</h2><ol><li><p>public int length()            获取字符串的长度返回(就是字符个数</p><pre><code> &#39;&#39;&#39;java     System.out.println(str.length()); &#39;&#39;&#39;</code></pre></li><li><p>public char charAt(int index)        获取某个索引位置处的字符返回   </p><pre><code> &#39;&#39;&#39;java     for (int i = 0; i &lt; str.length(); i++) &#123;                 char ch = str.charAt(i);                 System.out.println(ch);             &#125; &#39;&#39;&#39;</code></pre></li><li><p>public char[] toCharArray():         将当前字符串转换成字符数组返回</p><pre><code> &#39;&#39;&#39;java     char[] chars = str.toCharArray(); &#39;&#39;&#39;</code></pre></li><li><p>public boolean equals(Object anObject)   判断当前字符串与另一个字符串的内容一样，一样返回true</p><pre><code> &#39;&#39;&#39;java     System.out.println(str.equals(str2)); &#39;&#39;&#39;</code></pre></li><li><p>public boolean equalsIgnoreCase(String anotherString)   判断当前字符串与另一个字符串的内容是否一样(忽略大小写)</p><pre><code> &#39;&#39;&#39;java     System.out.println(str.equalsIgnoreCase(str2)); &#39;&#39;&#39;</code></pre></li><li><p>public String substring(int beginIndex, int endIndex)    根据开始和结束索引进行截取，得到新的字符串(包前不包后)</p><pre><code> &#39;&#39;&#39;java     String rar = &quot;学java死路一条&quot;;             System.out.println(rar.substring(0, 5)); &#39;&#39;&#39;</code></pre></li><li><p>public String substring(int beginIndex)      从传入的索引处截取，截取到末尾，得到新的字符串返回</p><pre><code> &#39;&#39;&#39;java     System.out.println(rar.substring(5)); &#39;&#39;&#39;</code></pre></li><li><p>public String replace(CharSequence target，CharSequence replacement)        使用新值，将字符串中的旧值替换，得到新的字符串</p><pre><code> &#39;&#39;&#39;java     System.out.println(rar.replace(&quot;学&quot;, &quot;卷&quot;)); &#39;&#39;&#39;</code></pre></li><li><p>public boolean contains(CharSequence s)          判断字符串中是否包含了某个字符串</p><pre><code> &#39;&#39;&#39;java     System.out.println(rar.contains(&quot;java&quot;)); &#39;&#39;&#39;</code></pre></li><li><p>public boolean startswith(string prefix)            判断字符串是否以某个字符串内容开头，开头返回true，反之</p><pre><code>&#39;&#39;&#39;java    System.out.println(rar.startsWith(&quot;学java&quot;));&#39;&#39;&#39;</code></pre></li><li><p>public String[] split(string regex)              把字符串按照某个字符串内容分割，并返回字符串数组回来    </p><pre><code>&#39;&#39;&#39;java    String string = &quot;呵呵哒，呵呵哒，呵呵哒&quot;;            String[] heheda = string.split(&quot;，&quot;);             for (int i = 0; i &lt; heheda.length; i++) &#123;                System.out.println(heheda[i]);            &#125;&#39;&#39;&#39;</code></pre></li></ol><h2 id="ArrayList类的常用方法"><a href="#ArrayList类的常用方法" class="headerlink" title="ArrayList类的常用方法"></a>ArrayList类的常用方法</h2><p>1. </p><p>add(E e)  将指定元素添加到集合的末尾</p><pre><code>    &#39;&#39;&#39;Java        ArrayList list = new ArrayList();        list.add(&quot;呵呵哒&quot;);        list.add(123);        list.add(1.22);        System.out.println(list);    &#39;&#39;&#39;</code></pre><p>2.<br>add(int i, E e) 往集合中的某个索引位置添加元素</p><pre><code>    &#39;&#39;&#39;Java        list.add(1, &quot;heheda&quot;);        list.add(1,&quot;呵&quot;);        System.out.println(list);    &#39;&#39;&#39;</code></pre><p>3.<br>get(int i)  获取指定索引位置的值</p><pre><code>    &#39;&#39;&#39;java        System.out.println(list.get(1));    &#39;&#39;&#39;</code></pre><p>4.<br>size()  返回集合中的元素数量</p><pre><code>    &#39;&#39;&#39;java        System.out.println(list.size());    &#39;&#39;&#39;</code></pre><p>5.<br>remove(int i)    删除指定索引位置的元素， 并返回删除的值</p><pre><code>    &#39;&#39;&#39;java        System.out.println(list.remove(1));     &#39;&#39;&#39;</code></pre><p>6.<br>remove(Object j)   删除指定的元素， 并返回删除是否成功</p><pre><code>    &#39;&#39;&#39;java        System.out.println(list.remove(&quot;呵&quot;));  //默认删除第一个出现的指定元素    &#39;&#39;&#39;</code></pre><p>7.<br>set(int i, Element e)  替换指定索引位置的元素, 并返回被修改的值</p><pre><code>    &#39;&#39;&#39;java        System.out.println(list.set(1, &quot;呵呵哒&quot;));    &#39;&#39;&#39;</code></pre><h1 id="包装类的一些方法"><a href="#包装类的一些方法" class="headerlink" title="包装类的一些方法"></a>包装类的一些方法</h1><h4 id="Objects类的常用方法"><a href="#Objects类的常用方法" class="headerlink" title="Objects类的常用方法"></a>Objects类的常用方法</h4><p>equals(Object a, Object b)  判断两个对象内容是否相等</p><pre><code>    &#39;&#39;&#39;java        String str = &quot;heheda&quot;;        String str2 = &quot;heheda&quot;;        System.out.println(str.equals(str2));  //原来这种方法有安全问题， 可能报空指针异常        System.out.println(Objects.equals(str, str2));    &#39;&#39;&#39;</code></pre><p>isNull(Object obj)  判断一个对象是否是null </p><pre><code>    &#39;&#39;&#39;java            String str = null;            String str2 = &quot;heheda&quot;;            // System.out.println(str.equals(str2));            System.out.println(Objects.equals(str, str2));            System.out.println(Objects.isNull(str));            System.out.println(Objects.isNull(str2));    &#39;&#39;&#39;</code></pre><p>nonNull(Object obj) 判断一个对象是否不是null</p><pre><code>    &#39;&#39;&#39;java        System.out.println(Objects.nonNull(str2));    &#39;&#39;&#39;</code></pre><h4 id="Interger类的常用方法-以此类推其他基本数据类型包装类"><a href="#Interger类的常用方法-以此类推其他基本数据类型包装类" class="headerlink" title="Interger类的常用方法, 以此类推其他基本数据类型包装类"></a>Interger类的常用方法, 以此类推其他基本数据类型包装类</h4><p>toString(int i)  </p><pre><code>    &#39;&#39;&#39;        Integer a = 123;//自动装箱        System.out.println(a.toString());        String str = Integer.toString(a);        System.out.println(str);        //自动拆箱        int a2 = a;    &#39;&#39;&#39;</code></pre><p>可以把基本数据类型转换成字符串数据类型</p><p>toString(double d)<br>toString()</p><pre><code>    &#39;&#39;&#39;        int a2 = a;        Integer.toString(a2);        String sttr = a.toString();    &#39;&#39;&#39;</code></pre><p>可以把字符串数值转换成对应数值的数据类型</p><p>parseInt(String str)<br>valueOf(String str)</p><pre><code>    &#39;&#39;&#39;        int i = Integer.parseInt(sttr);        int j = Integer.valueOf(sttr);    &#39;&#39;&#39;</code></pre><h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><p>append(任意类型)   &#x2F;&#x2F;添加各种类型的数据</p><pre><code>&#39;&#39;&#39;        StringBuilder stringBuilder = new StringBuilder(&quot;呵呵哒&quot;);        stringBuilder.append(1);        stringBuilder.append(&quot;呵呵哒&quot;);        stringBuilder.append(true);        System.out.println(stringBuilder);        //允许连续拼接        stringBuilder.append(&quot;呵呵哒&quot;).append(&quot;呵呵哒&quot;).append(111);&#39;&#39;&#39;</code></pre><p>reverse（）       &#x2F;&#x2F;将对象的内容反转</p><pre><code>&#39;&#39;&#39;    //反转操作    stringBuilder.reverse();    System.out.println(stringBuilder);&#39;&#39;&#39;</code></pre><p>length()       &#x2F;&#x2F;返回对象内容长度</p><pre><code>&#39;&#39;&#39;    stringBuilder.length();&#39;&#39;&#39;</code></pre><p>toString()            &#x2F;&#x2F;转换为String并返回内容</p><pre><code>&#39;&#39;&#39;    stringBuilder.toString();    &#39;&#39;&#39;</code></pre><p>###StringJoiner类 </p><p>public StringJoiner(间隔符)</p><pre><code>&#39;&#39;&#39;        StringJoiner str = new StringJoiner(&quot;, &quot;);        str.add(&quot;呵呵哒&quot;);        str.add(&quot;呵呵哒&quot;);        str.add(&quot;呵呵哒&quot;);        str.add(&quot;呵呵哒&quot;);        System.out.println(str);&#39;&#39;&#39;</code></pre><p>public StringJoiner(间隔符， 开始符号， 结束符号)</p><pre><code>&#39;&#39;&#39;    StringJoiner str2 = new StringJoiner(&quot;, &quot;,&quot;[&quot;,&quot;]&quot;);    str2.add(&quot;呵呵哒&quot;);    str2.add(&quot;呵呵哒&quot;);    str2.add(&quot;呵呵哒&quot;);    str2.add(&quot;呵呵哒&quot;);    System.out.println(str2);&#39;&#39;&#39;</code></pre><h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><p>System.exits()<br>Ststem.currentTimeMillis() 获取1970 1-1 0:0：0开始走到此刻的毫秒值<br>        ‘’’<br>                &#x2F;&#x2F;        System.exit(0);&#x2F;&#x2F;终止java虚拟机</p><pre><code>            long time1 = System.currentTimeMillis();            for (int i = 0; i &lt; 1000000; i++) &#123;                System.out.println(i);            &#125;            long time2 = System.currentTimeMillis();            String time = (time2 - time1)/ 1000.0 +&quot;s&quot;;            System.out.println(time);    &#39;&#39;&#39;</code></pre><h3 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h3><p>exit()  终止虚拟机操作， 一般不用</p><pre><code>    &#39;&#39;&#39;        // Runtime.getRuntime().exit(0);  //终止虚拟机    &#39;&#39;&#39;</code></pre><p>availableProcessors()  返回虚拟机能调用的处理器数量</p><pre><code>    &#39;&#39;&#39;        System.out.println(Runtime.getRuntime().availableProcessors()); //返回虚拟机能使用的处理器数量    &#39;&#39;&#39;</code></pre><p>totalMemory()   返回虚拟机中内存总量， long类型 字节</p><pre><code>    &#39;&#39;&#39;        System.out.println(Runtime.getRuntime().totalMemory());  //返回虚拟机中内存总量        System.out.println(Runtime.getRuntime().totalMemory() / 1024.0 / 1024.0 + &quot;MB&quot;);    &#39;&#39;&#39;</code></pre><p>freeMemory() 返回虚拟机中空闲的内存数量</p><pre><code>    &#39;&#39;&#39;        System.out.println(Runtime.getRuntime().freeMemory()/ 1024.0 / 1024.0 + &quot;MB&quot;);//返回虚拟机中空闲的内存数量    &#39;&#39;&#39;</code></pre><p>exec()  根据路径启动某个程序， 需要管理员权限</p><pre><code>    &#39;&#39;&#39;        Runtime.getRuntime().exec(&quot;D:\\Star Rail\\launcher.exe&quot;);  //启动 某个程序， idea需要管理员权限    &#39;&#39;&#39;</code></pre><p>Process.destroy();   &#x2F;&#x2F;用于结束通过exec启动的程序</p><pre><code>    &#39;&#39;&#39;        Process p = Runtime.getRuntime().exec(&quot;D:\\Star Rail\\launcher.exe&quot;);  //启动 某个程序， idea需要管理员权限, 返回Process类， 即软件对象        Thread.sleep(5000);  //让程序在此等待5s        p.destroy();  //结束这个软件    &#39;&#39;&#39;</code></pre><h3 id="BigDecimal类，-在java中-浮点类数据计算可能出现精度问题，-用BigDecimal类可以解决"><a href="#BigDecimal类，-在java中-浮点类数据计算可能出现精度问题，-用BigDecimal类可以解决" class="headerlink" title="BigDecimal类， 在java中 浮点类数据计算可能出现精度问题， 用BigDecimal类可以解决"></a>BigDecimal类， 在java中 浮点类数据计算可能出现精度问题， 用BigDecimal类可以解决</h3><pre><code>&#39;&#39;&#39;        BigDecimal a = BigDecimal.valueOf(0.1);        BigDecimal b = BigDecimal.valueOf(0.2);        System.out.println(a.add(b)); //加        System.out.println(a.subtract(b));  //减        System.out.println(a.multiply(b));  // 乘        System.out.println(a.divide(b));   //除        System.out.println(b.divide(a, 3, RoundingMode.HALF_UP));   //除数  精确几位， 舍入模式&#39;&#39;&#39;</code></pre><h3 id="Date类和Simpledateformat类"><a href="#Date类和Simpledateformat类" class="headerlink" title="Date类和Simpledateformat类"></a>Date类和Simpledateformat类</h3><pre><code>&#39;&#39;&#39;        Date d = new Date();        System.out.println(d);        long time = d.getTime();        System.out.println(time);        SimpleDateFormat s = new SimpleDateFormat(&quot;yyyy-MM-dd HH时mm分ss秒 EEE a&quot;);        System.out.println(s.format(time));        System.out.println(s.format(d));        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;);        System.out.println(simpleDateFormat.format(d));        simpleDateFormat.format(time);        String dtime = &quot;2022-12-12 12:11&quot;;        SimpleDateFormat s2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);        System.out.println(s2.parse(dtime));&#39;&#39;&#39;</code></pre><h3 id="Calander类"><a href="#Calander类" class="headerlink" title="Calander类"></a>Calander类</h3><pre><code>&#39;&#39;&#39;        Calendar ca = Calendar.getInstance();        System.out.println(ca);        int i = ca.get(Calendar.MONTH);             System.out.println(i);        ca.set(Calendar.MONTH, 10);        System.out.println(ca);        ca.add(Calendar.DAY_OF_YEAR, 10);        ca.add(Calendar.DAY_OF_YEAR, -10);        System.out.println(ca);&#39;&#39;&#39;</code></pre><h2 id="JDK8新增的时间日期类"><a href="#JDK8新增的时间日期类" class="headerlink" title="JDK8新增的时间日期类"></a>JDK8新增的时间日期类</h2><p>LocalDate :代表本地日期（年、月、日、星期）<br>LocalTime： 代表本地时间（时、分、秒、纳秒）<br>LocalDateTime：代表本地日期时间：（年、月、日、星期、时、分、秒、纳秒） &#x2F;&#x2F;用的最多</p><p>以LocalDate类为例：</p><p>‘’’<br>        LocalDate localDate &#x3D; LocalDate.now();<br>        System.out.println(localDate);<br>        System.out.println(localDate.getYear());<br>        System.out.println(localDate.getMonth());<br>        System.out.println(localDate.getDayOfMonth());<br>        System.out.println(localDate.getDayOfWeek().getValue());</p><pre><code>    LocalDate localDate1 = localDate.withYear(2099); //返回新的localdate类型， 原来的对象数据不变    System.out.println(localDate1);    System.out.println(localDate);    LocalDate localDate2 = localDate.withMonth(12); //返回新的localdate类型， 原来的对象数据不变    System.out.println(localDate2);    localDate.plusYears(2);  //加两年， 返回新的对象    localDate.minusYears(2); //减两年， 返回新的对象    LocalDate.of(2022, 12, 10);//获取指定时间对象， 返回新的对象    localDate.equals(localDate1); //判断日期对象是否相等    localDate.isAfter(localDate1); //判断日期是否在指定对象后面    localDate.isBefore(localDate1); //判断日期是否在指定对象后面</code></pre><p>‘’’<br>剩下的两类以此类推， 方法名是一样的<br>其中， LocalDateTime可以分开也可合并</p><p>‘’’<br>        LocalDate l1 &#x3D; localDateTime.toLocalDate(); &#x2F;&#x2F;分开<br>        LocalTime l2 &#x3D; localDateTime.toLocalTime();</p><pre><code>    LocalDateTime of = LocalDateTime.of(l1, l2);  //合并</code></pre><p>‘’’</p><h4 id="ZonId类和Instant类"><a href="#ZonId类和Instant类" class="headerlink" title="ZonId类和Instant类"></a>ZonId类和Instant类</h4><p>ZonId主要获取时区对象<br>Instant用以替代原来的DAte对象</p><p>‘’’</p><pre><code>    ZoneId z = ZoneId.systemDefault();    System.out.println(z.getId());    System.out.println(z);    System.out.println(ZoneId.getAvailableZoneIds());    ZoneId of = ZoneId.of(&quot;Asia/Aden&quot;);    System.out.println(of);    System.out.println(ZonedDateTime.now(of));    System.out.println(ZonedDateTime.now(Clock.systemUTC())); //世界标准时间    Instant i = Instant.now();    System.out.println(i.getEpochSecond());</code></pre><p>‘’’</p><h4 id="Period类和Duration类"><a href="#Period类和Duration类" class="headerlink" title="Period类和Duration类"></a>Period类和Duration类</h4><p>Period类用于计算两个localDAte类相差的年月日<br>Duration类用于计算两个时间对象相差的天、小时、分、秒、纳秒<br>用法同上或见API文档</p><p>‘’’<br>        LocalDate localDateTime1 &#x3D; LocalDate.of(2022, 11, 11);<br>        LocalDate localDateTime2 &#x3D; LocalDate.of(2023, 12, 12);</p><pre><code>    Period p = Period.between(localDateTime1, localDateTime2);    System.out.println(p.getYears());    System.out.println(p.getMonths());    LocalDateTime loc1 = LocalDateTime.of(2022, 2, 11, 12, 24, 48);    LocalDateTime loc2 = LocalDateTime.of(2022, 12, 12, 3, 48, 59);    Duration duration = Duration.between(loc1, loc2);    System.out.println(duration.toDays());</code></pre><p>‘’’</p><h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><p>‘’’<br>        LocalDate localDateTime1 &#x3D; LocalDate.of(2022, 11, 11);<br>        LocalDate localDateTime2 &#x3D; LocalDate.of(2023, 12, 12);</p><pre><code>    Period p = Period.between(localDateTime1, localDateTime2);    System.out.println(p.getYears());    System.out.println(p.getMonths());    LocalDateTime loc1 = LocalDateTime.of(2022, 2, 11, 12, 24, 48);    LocalDateTime loc2 = LocalDateTime.of(2022, 12, 12, 3, 48, 59);    Duration duration = Duration.between(loc1, loc2);    System.out.println(duration.toDays());    </code></pre><p>‘’’</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于主题配置位置的说明</title>
      <link href="/2023/09/22/%E5%85%B3%E4%BA%8E%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%AF%B4%E6%98%8E/"/>
      <url>/2023/09/22/%E5%85%B3%E4%BA%8E%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p>butterfly主题配置的文件处于Myblog\node_modules\hexo-theme-butterfly 中</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的试用文章</title>
      <link href="/2023/09/20/%E6%88%91%E7%9A%84%E8%AF%95%E7%94%A8%E6%96%87%E7%AB%A0/"/>
      <url>/2023/09/20/%E6%88%91%E7%9A%84%E8%AF%95%E7%94%A8%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落</p><p>示例段落示例段落示例段落</p><p>示例段落示例段落示例段落</p><p>示例段落示例段落示例段落</p><p><em>斜体文本</em></p><p><strong>粗体文本</strong></p><p><em><strong>粗斜体文本</strong></em></p><p>这是一个分隔符</p><hr><hr><p>* </p><p>- </p><hr><hr><hr><p><del>这是删除</del></p><p>这是无序列表</p><p>* </p><ul><li></li><li></li></ul><ul><li>一</li><li>二</li><li>三</li></ul><ul><li></li><li></li><li></li></ul><p>这是有序列表</p><p>1.<br>2.<br>3.  </p><ol><li>第一项<ul><li>子列表1</li><li>子列表2</li><li>子列表3</li></ul></li><li>第二项：<ul><li>子列表1</li><li>子列表2</li><li>子列表3</li></ul></li></ol><p>引用</p><blockquote><p>引用的内容</p><p>这是内容</p></blockquote><blockquote><p>第二段引用 的内容</p><p>这是内容</p></blockquote><p>区块嵌套</p><blockquote><p>引用</p><blockquote><p>引用</p></blockquote></blockquote><blockquote><blockquote><blockquote></blockquote><blockquote><blockquote></blockquote></blockquote></blockquote></blockquote><p>‘’’c</p><p>#include &lt;stdio.h&gt;</p><p>int main()</p><p>{</p><pre><code> printf(&quot;Hello World !&quot;);</code></pre><p>​return 0;</p><p>}</p><p>‘’’</p><p><a href="www.moussemou.cn">链接名称</a></p><p>&lt;<a href="http://www.moussemou.cn>">www.moussemou.cn&gt;</a></p><p><a href="https://www.msn.cn/zh-cn/news/other/%E8%B5%B5%E6%98%8E-%E8%8D%A3%E8%80%80%E5%9B%9E%E5%BD%92%E5%8D%8E%E4%B8%BA%E7%BB%9D%E6%97%A0%E5%8F%AF%E8%83%BD/ar-AA1gWELc?ocid=msedgntp&pc=EDGENTP&cvid=563da8064b7a40fc84fa3aff76c9c7c2&ei=6">图片描述</a></p><p>表格</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/09/19/hello-world/"/>
      <url>/2023/09/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
