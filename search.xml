<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>特殊文件、日志</title>
      <link href="/2023/11/01/%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E3%80%81%E6%97%A5%E5%BF%97/"/>
      <url>/2023/11/01/%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E3%80%81%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h2 id="Properties后缀文件"><a href="#Properties后缀文件" class="headerlink" title="Properties后缀文件"></a>Properties后缀文件</h2><pre><code>&#39;&#39;&#39;    Properties p = new Properties();    p.load(new FileReader(&quot;Test_1028_mousse\\src\\UserTest.properties&quot;)); //读出目标数据    System.out.println(p.getProperty(&quot;name&quot;));  //根据键读取值    System.out.println(p.getProperty(&quot;age&quot;));    System.out.println(p.getProperty(&quot;score&quot;));    Set&lt;String&gt; strs = p.stringPropertyNames();    for (String str : strs) &#123;        System.out.println(str+&quot;----&quot;+p.getProperty(str));  //遍历键值对    &#125;    p.forEach((k, v)-&gt; &#123;        System.out.println(k +&quot;--&quot;+v);   //遍历键值对    &#125;);&#39;&#39;&#39;&#39;&#39;&#39;    //写进属性    Properties p = new Properties();    p.setProperty(&quot;name&quot;, &quot;呵呵哒&quot;);    p.setProperty(&quot;age&quot;, &quot;12&quot;);    p.setProperty(&quot;score&quot;, &quot;97&quot;);    p.store(new FileWriter(&quot;Test_1028_mousse\\src\\UserTest2.properties&quot;), &quot;这里必须写注释&quot;);&#39;&#39;&#39;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IO流的使用</title>
      <link href="/2023/10/30/IO%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/10/30/IO%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="FileInputStream类"><a href="#FileInputStream类" class="headerlink" title="FileInputStream类"></a>FileInputStream类</h2><pre><code>&#39;&#39;&#39;//        File f1 = new File(&quot;D:\\LearrnMoreJavaTest\\Test_1028_mousse\\src\\IOpackage\\heheda.txt&quot;);//        f1.mkdirs();        FileInputStream f1 = new FileInputStream(&quot;D:\\LearrnMoreJavaTest\\Test_1028_mousse\\heheda.txt&quot;); //获取源文件//        System.out.println(f1.read());  //读取第一个字节//        System.out.println(f1.read());  //读取第二个字节//        System.out.println(f1.read());  //读取第三个字节//        System.out.println(f1.read());  //读取第四个字节    int b;    while ((b = f1.read()) != -1)&#123;   //若读取到尽头， 则会返回负1        System.out.print(b);    &#125;    f1.close();   //流使用完必须关闭， 释放系统资源&#39;&#39;&#39;&#39;&#39;&#39;        FileInputStream f1 = new FileInputStream(&quot;Test_1028_mousse\\heheda.txt&quot;);        //        byte[] b1 = new byte[3];  //建立一个字节数组， 用以存放每次读取的字节， 数量根据要读取的字符决定        //        int len = f1.read(b1);  //返回当次读取的字节数量， 此时b1存储三个字节        //        String s = new String(b1); //返回当前读取的内容        //        System.out.println(len);        //        System.out.println(s);        //        int len2 = f1.read(b1);        //        System.out.println(new String(b1));        //        int len3 = f1.read(b1);        //        System.out.println(new String(b1));        //        //        int len4 = f1.read(b1);        //        System.out.println(new String(b1, 0, len4)); //从0开始读写， 到读取字节的数量。 读多少就倒多少               //循环输出          //        int len;        //        byte [] b = new byte[3];        //        while ((len = f1.read(b) ) != -1 )&#123;        //            System.out.print(new String(b, 0, len));  //读多少倒多少        //        &#125;        //        File file1 = new File(&quot;Test_1028_mousse\\heheda.txt&quot;);        //        long length = file1.length();        //        byte[] b = new byte[(int) length];    //一次读完全部内容        //        int read = f1.read(b);        //        System.out.println(new String(b));        f1.close();&#39;&#39;&#39;</code></pre><h2 id="FileOutputStream类、"><a href="#FileOutputStream类、" class="headerlink" title="FileOutputStream类、"></a>FileOutputStream类、</h2><pre><code>&#39;&#39;&#39;    OutputStream f1 = new FileOutputStream(&quot;Test_1028_mousse/呵呵哒.txt&quot;);  //这是覆盖管道， 会覆盖原来的数据    f1.write(97);    f1.write(&#39;h&#39;);    byte[] b = &quot;呵呵哒呵呵哒呵呵哒&quot;.getBytes();   //getBytes方法将字符串拆分返回字符数组形式    f1.write(b);    f1.close();    OutputStream f2 = new FileOutputStream(&quot;Test_1028_mousse/呵呵哒呵呵哒.txt&quot;, true); //这是追加管道， 不会覆盖原来的数据    byte[] b2 = &quot;呵呵哒呵呵哒呵呵&quot;.getBytes();    f2.write(b2);    f2.write(&quot;\r\n&quot;.getBytes());  //\n换行不一定兼容全部平台， \r\n兼容全部平台    f2.write(b2);    f2.close();&#125;&#39;&#39;&#39;&#39;&#39;&#39;//复制案例    InputStream f1 = new FileInputStream(&quot;C:\\Users\\24084\\Desktop\\娱乐\\FuX.jpg&quot;);    OutputStream f2 = new FileOutputStream(&quot;C:\\Users\\24084\\Desktop\\娱乐\\FuXing.jpg&quot;);    int len;    byte[] b = new byte[1024];    while ((len = f1.read(b))!= -1)&#123;        f2.write(b, 0, len);    &#125;      f2.close();                    //先关闭后创建的流    f1.close();                    //再关闭前创建的流    System.out.println(&quot;复制完成&quot;);&#39;&#39;&#39;下面是规范的写法：&#39;&#39;&#39;    InputStream f1 = null;    OutputStream f2 = null;    try &#123;        f1 = new FileInputStream(&quot;C:\\Users\\24084\\Desktop\\娱乐\\FuX.jpg&quot;);        f2 = new FileOutputStream(&quot;C:\\Users\\24084\\Desktop\\娱乐\\FuXingCopy2.jpg&quot;);        int len;        byte[] b = new byte[1024];        while ((len = f1.read(b)) != -1) &#123;            f2.write(b, 0, len);        &#125;    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125; finally &#123;        if (f2 != null) &#123;            try &#123;                f2.close();                    //先关闭后创建的流            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        if (f1 != null) &#123;            try &#123;                f1.close();                    //再关闭前创建的流                System.out.println(&quot;复制完成&quot;);            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#39;&#39;&#39;&#39;&#39;&#39; jdk7后的写法， try()括号里写流， 会自动释放， 可以省去finally        try(            InputStream f1 = new FileInputStream(&quot;C:\\Users\\24084\\Desktop\\娱乐\\FuX.jpg&quot;);            OutputStream f2 =  new FileOutputStream(&quot;C:\\Users\\24084\\Desktop\\娱乐\\Kafka&amp;Setelite.jpg&quot;);        ) &#123;            int len;            byte[] b = new byte[1024];            while ((len = f1.read(b))!= -1)&#123;                f2.write(b, 0, len);            &#125;        System.out.println(&quot;复制成功&quot;);    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;&#39;&#39;&#39;</code></pre><h2 id="FileReader字符流类的使用"><a href="#FileReader字符流类的使用" class="headerlink" title="FileReader字符流类的使用"></a>FileReader字符流类的使用</h2><pre><code>&#39;&#39;&#39;        try(Reader f1 = new FileReader(&quot;Test_1028_mousse\\呵呵哒呵呵哒.txt&quot;);) &#123;        int c; //记录每次读取的字符序号//            while ((c = f1.read())!= -1)&#123;//                System.out.print((char)c);    //把每次读取的字符序号转换成字符类型//            &#125;        char[] b = new char[3];  //创建字符串数组        while ((c = f1.read(b)) != -1) &#123;            System.out.print(new String(b, 0, c));   //写多少倒多少        &#125;    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#39;&#39;&#39;</code></pre><h2 id="FileWriter字符流类的使用"><a href="#FileWriter字符流类的使用" class="headerlink" title="FileWriter字符流类的使用"></a>FileWriter字符流类的使用</h2><pre><code>&#39;&#39;&#39;//        try(Writer f1 = new FileWriter(&quot;Test_1028_mousse\\呵呵哒o.txt&quot;);) &#123;//            f1.write(&#39;h&#39;);  //可以写一个字符////            f1.write(&quot;呵呵哒&quot;);//可以写字符串//            char[] c = new char[]&#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;;//            f1.write(c);  //可以写字符数组//            f1.write(c, 0 ,1);  //可以根据需求写字符数组， 从0个到1， 写a和b//            f1.write(&quot;\r\n&quot;);   //可直接写换行符//            f1.write(&quot;呵呵哒&quot;, 0, 1); //字符串同理////        &#125; catch (IOException e) &#123;//            e.printStackTrace();//        &#125;    Writer f1 = new FileWriter(&quot;Test_1028_mousse\\\\呵呵哒2.txt&quot;);    f1.write(&quot;呵呵哒&quot;);    f1.write(&quot;呵呵哒&quot;);    f1.write(&quot;呵呵哒&quot;);    f1.flush();   //字符流使用完毕必须刷新或者关闭， 否则不会写出数据    //刷新后的流还可以继续使用    f1.write(&quot;\r\n&quot;);    f1.write(&quot;、、、、呵呵哒&quot;);    f1.flush();   //写完之后必须刷新， 或者关闭    f1.close();   //关闭流包含刷新流， 关闭后不能再使用流了。&#125;&#39;&#39;&#39;</code></pre><h2 id="字节缓冲输入输出流"><a href="#字节缓冲输入输出流" class="headerlink" title="字节缓冲输入输出流"></a>字节缓冲输入输出流</h2><pre><code>&#39;&#39;&#39;    try (        InputStream f1 = new FileInputStream(&quot;Test_1028_mousse\\呵呵哒.txt&quot;);        InputStream f1h = new BufferedInputStream(f1);   //字节输入缓冲流        OutputStream f2 = new FileOutputStream(&quot;Test_1028_mousse\\呵呵哒3.txt&quot;);        OutputStream f2h = new BufferedOutputStream(f2);)&#123;        int len;        byte [] c=  new byte[1024];        while ((len = f1h.read(c))!=-1)&#123;            f2h.write(c, 0, len);        &#125;        System.out.println(&quot;复制完成&quot;);    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#39;&#39;&#39;</code></pre><h2 id="字符缓冲输入输出流"><a href="#字符缓冲输入输出流" class="headerlink" title="字符缓冲输入输出流"></a>字符缓冲输入输出流</h2><pre><code>&#39;&#39;&#39;        try ( FileReader f1 = new FileReader(&quot;Test_1028_mousse\\呵呵哒呵呵哒.txt&quot;);          BufferedReader b1 = new BufferedReader(f1);)&#123;//            System.out.println(b1.readLine());   //直接读取一行//            System.out.println(b1.readLine());//            System.out.println(b1.readLine());        String str;        while ((str = b1.readLine())!= null)&#123;            System.out.println(str);         //有多少行读多少行        &#125;    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#39;&#39;&#39;</code></pre><h2 id="字符输入转换流"><a href="#字符输入转换流" class="headerlink" title="字符输入转换流"></a>字符输入转换流</h2><pre><code>InputStreamReader类实现， 输出转换流同理。&#39;&#39;&#39;    try (InputStreamReader f1 = new InputStreamReader(new FileInputStream(&quot;D:\\LearrnMoreJavaTest\\Test_1028_mousse\\呵呵哒呵呵哒.txt&quot;), &quot;UTF-8&quot;);         BufferedReader b1 = new BufferedReader(f1);    )&#123;        String str;        while ((str = b1.readLine())!= null)&#123;            System.out.println(str);        &#125;    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#39;&#39;&#39;</code></pre><h2 id="字节字符打印流"><a href="#字节字符打印流" class="headerlink" title="字节字符打印流"></a>字节字符打印流</h2><p>printStream:<br>printWriter同理， 主要用打印功能<br>    ‘’’<br>            try (PrintStream p1 &#x3D; new PrintStream(“Test_1028_mousse\呵呵哒呵呵哒2.txt”);){<br>            p1.println(“呵呵哒”);   &#x2F;&#x2F;可以直接打印出去<br>            p1.println(“呵呵哒”);<br>            p1.println(“呵呵哒”);<br>            p1.write(97);</p><pre><code>    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#125;&#39;&#39;&#39;</code></pre><h2 id="数据输入输出流"><a href="#数据输入输出流" class="headerlink" title="数据输入输出流"></a>数据输入输出流</h2><pre><code>&#39;&#39;&#39;  DataOutputStream: 写出数据        try (DataOutputStream d1 = new DataOutputStream(new FileOutputStream(&quot;Test_1028_mousse\\呵呵哒呵呵哒3.txt&quot;));//             DataInputStream d2 = new DataInputStream(new FileInputStream(&quot;Test_1028_mousse\\呵呵哒呵呵哒3.txt&quot;));    )&#123;        d1.writeInt(1);  //按指定类型写数据        d1.writeInt(2);        d1.writeInt(3);        d1.writeUTF(&quot;呵呵哒&quot;);        d1.writeUTF(&quot;呵呵哒&quot;);        d1.writeDouble(1.1);    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#39;&#39;&#39;&#39;&#39;&#39;DataInputStream: 读入数据        try (DataInputStream d1 = new DataInputStream(new FileInputStream(&quot;Test_1028_mousse\\呵呵哒呵呵哒3.txt&quot;));)&#123;        System.out.println(d1.readInt());   //必须按写的顺序读， 并且指定类型        System.out.println(d1.readInt());        System.out.println(d1.readInt());        System.out.println(d1.readUTF());//            System.out.println(d1.readDouble());        System.out.println(d1.readUTF());        System.out.println(d1.readDouble());    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#39;&#39;&#39;</code></pre><h2 id="对象输入输出流"><a href="#对象输入输出流" class="headerlink" title="对象输入输出流"></a>对象输入输出流</h2><pre><code>&#39;&#39;&#39;    //ObjectOutputStream:  写入对象数据    try(ObjectOutputStream o1 = new ObjectOutputStream(new FileOutputStream(&quot;Test_1028_mousse\\呵呵哒呵呵哒4.txt&quot;));) &#123;        Users u1 = new Users(&quot;呵呵哒&quot;, 12);        o1.writeObject(u1);        System.out.println(&quot;对象序列化成功！&quot;);    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#39;&#39;&#39;&#39;&#39;&#39;ObjectInputStream:读取对象数据        try (ObjectInputStream o1 = new ObjectInputStream(new FileInputStream(&quot;Test_1028_mousse\\呵呵哒呵呵哒4.txt&quot;));)&#123;        Users u = (Users)o1.readObject();        System.out.println(u.getName());        System.out.println(u.getAge());    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#39;&#39;&#39;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>File类的使用</title>
      <link href="/2023/10/29/File%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/10/29/File%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="File对象一些常用方法"><a href="#File对象一些常用方法" class="headerlink" title="File对象一些常用方法"></a>File对象一些常用方法</h2><pre><code>&#39;&#39;&#39;    File f1 = new File(&quot;C:\\Users\\24084\\Desktop\\学习笔记\\MySQL笔记.txt&quot;);  //获取文件对象    File f2 = new File(&quot;C:/Users/24084/Desktop/学习笔记/MySQL笔记.txt&quot;);  //用正斜杠也可。 只需一个/    File f3 = new File(&quot;C:&quot; + File.separator + &quot;Users&quot;+File.separator+ &quot;24084&quot;+            File.separator+&quot;Desktop&quot;+File.separator+&quot;学习笔记&quot;+File.separator+&quot;MySQL笔记.txt&quot;);  //也可用file类自带的常量分割， 分隔符由系统决定    System.out.println(f1.length());    //返回文件的字节个数    System.out.println(f2.length());    //返回文件的字节个数    System.out.println(f3.length());    //返回文件的字节个数    File f4 = new File(&quot;C:/Users/24084/Desktop/学习笔记&quot;);  //也可获取文件夹对象    System.out.println(f4.length());          //获取文件夹本身的大小， 并不包括文件夹里所有的内容    System.out.println(f4.exists());  //判断文件或文件夹是否存在    File f5 = new File(&quot;D:/呵呵哒&quot;);   //可以指代不存在的文件    System.out.println(f5.exists());  //判断文件或文件夹是否存在    File f6 = new File(&quot;D:\\LearrnMoreJavaTest\\Test_1028_mousse\\src\\com\\fileeTest\\呵呵哒.txt&quot;);//获取包里的文件， 这里是绝对路径    File f7 = new File(&quot;Test_1028_mousse\\src\\com\\fileeTest\\呵呵哒.txt&quot;);//获取包里的文件， 这里是相对路径, 从包开始找， 也可从工程开始， 加上工程路径    System.out.println(f7.length());    System.out.println(f7.isFile());//判断该文件是否是文件    System.out.println(f7.isDirectory()); //判断该文件是否是文件夹    System.out.println(f4.isDirectory()); //判断该文件是否是文件夹    System.out.println(f7.getName());  //获取文件的名字， 包括后缀    System.out.println(f7.lastModified()); //获取文件的最后修改时间    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);    System.out.println(sdf.format(f7.lastModified()));  //解析后的时间    System.out.println(f7.getPath());  //获取文件对象时， 使用的路径    System.out.println(f7.getAbsolutePath());  //获取文件的绝对路径&#39;&#39;&#39;</code></pre><h2 id="File类对象创建和删除文件的方法"><a href="#File类对象创建和删除文件的方法" class="headerlink" title="File类对象创建和删除文件的方法"></a>File类对象创建和删除文件的方法</h2><pre><code>&#39;&#39;&#39;    File f1 = new File(&quot;D:\\LearrnMoreJavaTest\\Test_1028_mousse\\src\\com\\fileeTest\\呵呵哒2.txt&quot;);    try &#123;        System.out.println(f1.createNewFile());   //创建文件， 成功返回true, 反之false        System.out.println(f1.createNewFile());   //如果已经存在， 那么返回false， 不会再次创建    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;    File f2 = new File(&quot;D:\\LearrnMoreJavaTest\\Test_1028_mousse\\src\\com\\fileeTest\\呵呵哒文件夹&quot;);    System.out.println(f2.mkdir());  //创建文件夹，成功返回true, 否则返回false 这个方法只能创建一级文件夹    File f3 = new File(&quot;D:\\LearrnMoreJavaTest\\Test_1028_mousse\\src\\com\\fileeTest\\一级文件\\二级文件\\三级文件&quot;);    System.out.println(f3.mkdirs());  //创建文件夹， 这个方法可以创建多级文件夹    System.out.println(f2.delete());  //删除文件夹， 不能删除非空文件夹    System.out.println(f3.delete());    //删除最外的三级文件    File f4 = new File(&quot;D:\\LearrnMoreJavaTest\\Test_1028_mousse\\src\\com\\fileeTest&quot;);    String[] list = f4.list();    //获取当前文件夹目录下所有一级文件名称， 并返回字符串数组    System.out.println(Arrays.toString(list));    File[] listFiles = f4.listFiles();   //获取当前文件夹目录下所有一级文件， 并返回文件数组    for (File listFile : listFiles) &#123;        System.out.println(listFile.getAbsolutePath());    &#125;&#39;&#39;&#39;</code></pre><h2 id="File类搜索文件的方法"><a href="#File类搜索文件的方法" class="headerlink" title="File类搜索文件的方法"></a>File类搜索文件的方法</h2><pre><code>&#39;&#39;&#39;    public static void searchFile(File file, String FileName) &#123;    if (file == null || !file.exists() || file.isFile()) &#123;        return;    &#125;    File[] files = file.listFiles();    if (files != null &amp;&amp; files.length &gt; 0) &#123;        for (File f : files) &#123;            if (f.isFile()) &#123;                if (f.getName().contains(FileName)) &#123;                    System.out.println(&quot;找到了：&quot; + f.getAbsolutePath());                    // Runtime runtime = Runtime.getRuntime();                    // try &#123;                    // runtime.exec(f.getAbsolutePath());                    //  &#125; catch (IOException e) &#123;                    //   e.printStackTrace();                    //  &#125;                &#125;            &#125; else &#123;                searchFile(f, FileName);            &#125;        &#125;    &#125;&#125;&#39;&#39;&#39;</code></pre><h2 id="File类删除多级文件的方法"><a href="#File类删除多级文件的方法" class="headerlink" title="File类删除多级文件的方法"></a>File类删除多级文件的方法</h2><pre><code>&#39;&#39;&#39;    public static void deleteFile(File file)&#123;    if (file==null||!file.exists())&#123;        return;    &#125;    if (file.isFile())&#123;        file.delete();    &#125;    File[] files = file.listFiles();    if (files!=null) &#123;        for (File f : files) &#123;            if (f.isFile()) &#123;                f.delete();            &#125; else &#123;                deleteFile(f);            &#125;        &#125;    &#125;    file.delete();&#125;&#39;&#39;&#39;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>“集合类的使用”</title>
      <link href="/2023/10/22/%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/10/22/%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Collection类的一些常用方法"><a href="#Collection类的一些常用方法" class="headerlink" title="Collection类的一些常用方法"></a>Collection类的一些常用方法</h2><pre><code>&#39;&#39;&#39;        Collection&lt;String&gt; coll = new ArrayList&lt;&gt;();        coll.add(&quot;呵呵哒&quot;);        coll.clear(); //清空该集合所有元素        coll.isEmpty();//判断是否是空集合        coll.size();//获取集合大小        coll.contains(&quot;呵呵哒&quot;);//判断集合是否包含某个指定元素        coll.remove(&quot;呵呵哒&quot;);//删除集合某个指定元素        coll.toArray(); //把集合转换成数组。&#39;&#39;&#39;</code></pre><h2 id="iterator类迭代器的使用"><a href="#iterator类迭代器的使用" class="headerlink" title="iterator类迭代器的使用"></a>iterator类迭代器的使用</h2><pre><code>&#39;&#39;&#39;        Collection&lt;String&gt; coll2 = new ArrayList&lt;&gt;();        coll2.add(&quot;呵呵哒&quot;);        coll2.add(&quot;呵呵哒&quot;);        coll2.add(&quot;呵呵哒&quot;);        coll2.add(&quot;呵呵哒&quot;);        coll2.add(&quot;呵呵哒&quot;);        coll.addAll(coll2);        Iterator&lt;String&gt; iterator = coll.iterator();        while (iterator.hasNext())&#123; //判断当前指向元素是否存在            System.out.println(iterator.next());   //输出当前指向元素        &#125;&#39;&#39;&#39;</code></pre><h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><p>   增强for循环遍历集合， 就是迭代器遍历集合的简化写法</p><pre><code>&#39;&#39;&#39;        for(String str : coll)&#123;  //增强for循环， 用以遍历数组或集合 格式为：for(数据类型 变量名 : 需要遍历的数组或集合) 其中， 变量名为被遍历的其中每一个元素            System.out.println(str);        &#125;        int [] arr = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;;           for (int i : arr)&#123;          //增强for循环遍历数组   快捷键： arr.for            System.out.println(i);        &#125;&#39;&#39;&#39;</code></pre><h3 id="集合的forEach方法，-用lambda表达式实现集合的遍历"><a href="#集合的forEach方法，-用lambda表达式实现集合的遍历" class="headerlink" title="集合的forEach方法， 用lambda表达式实现集合的遍历"></a>集合的forEach方法， 用lambda表达式实现集合的遍历</h3><pre><code>&#39;&#39;&#39;        coll.forEach(new Consumer&lt;String&gt;() &#123;  //coll是集合， 上面代码的集合            @Override            public void accept(String s) &#123;    //匿名内部类实现                System.out.println(s);            &#125;        &#125;);        coll.forEach(s -&gt; System.out.println(s));  //一部部简化        coll.forEach(System.out::println);   //最终简化版本&#39;&#39;&#39;</code></pre><h3 id="List类集合的使用"><a href="#List类集合的使用" class="headerlink" title="List类集合的使用"></a>List类集合的使用</h3><pre><code>&#39;&#39;&#39;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(0, &quot;呵呵哒&quot;);  //在指定位置插入指定元素， 可以和插入队伍        list.remove(0);  //删除指定索引位置的元素, 并返回被删除的元素        list.add(&quot;呵呵哒&quot;);        list.add(&quot;呵呵哒&quot;);        list.add(&quot;呵呵哒&quot;);        list.add(&quot;呵呵哒&quot;);        list.set(0, &quot;呵呵哒&quot;);  //修改指定索引位置的元素， 并返回被修改的值        list.get(0); //返回指定索引位置的元素&#39;&#39;&#39;</code></pre><h3 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h3><pre><code>&#39;&#39;&#39;        //创建队列！    LinkedList&lt;String&gt; link = new LinkedList();    link.addLast(&quot;呵呵哒1&quot;);  //在末位置增加元素    link.addLast(&quot;呵呵哒2&quot;);    link.addLast(&quot;呵呵哒3&quot;);    link.addLast(&quot;呵呵哒4&quot;);    link.addLast(&quot;呵呵哒5&quot;);    System.out.println(link);    link.removeFirst();     //删除头部元素    link.removeFirst();    System.out.println(link);    link.removeLast();     //删除尾部元素    link.removeLast();    System.out.println(link);    //        for (String s : link) &#123;    //            System.out.println(s);    //        &#125;    //创建栈！    LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();    list.addFirst(&quot;呵呵哒1&quot;);   //从头部增加元素    list.addFirst(&quot;呵呵哒2&quot;);    list.push(&quot;呵呵哒3&quot;);    list.push(&quot;呵呵哒4&quot;);   //push方法和addfirst是一样的    list.push(&quot;呵呵哒5&quot;);    System.out.println(list);    //出栈    list.removeFirst();    list.removeFirst();    list.pop();    list.pop();   //pop方法和removefirst是一样的    System.out.println(list);&#39;&#39;&#39;</code></pre><h3 id="Set类的三个子类"><a href="#Set类的三个子类" class="headerlink" title="Set类的三个子类"></a>Set类的三个子类</h3><p>   其中， linkedhashset类是hashset类的子类</p><pre><code>&#39;&#39;&#39;    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();   //无序， 不重复， 无索引    set.add(111);    set.add(222);    set.add(333);    set.add(444);    set.add(444);    set.add(444);    set.add(444);    System.out.println(set);    Set&lt;Integer&gt; setlink = new LinkedHashSet&lt;&gt;();  //有序， 不重复， 无索引    setlink.add(111);    setlink.add(222);    setlink.add(333);    setlink.add(444);    setlink.add(444);    setlink.add(444);    setlink.add(444);    System.out.println(setlink);    Set&lt;Integer&gt; treesets = new TreeSet&lt;&gt;();    //默认有序， 不重复， 无索引    treesets.add(444);    treesets.add(222);    treesets.add(1111);    treesets.add(777);    treesets.add(777);    System.out.println(treesets);&#39;&#39;&#39;</code></pre><h2 id="MAP集合"><a href="#MAP集合" class="headerlink" title="MAP集合"></a>MAP集合</h2><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><pre><code>&#39;&#39;&#39;        maptest.put(1, &quot;呵呵哒&quot;);        maptest.put(2, &quot;呵呵哒&quot;);        maptest.put(3, &quot;呵呵哒&quot;);        maptest.put(4, &quot;呵呵哒&quot;);        maptest.put(8, &quot;呵呵哒&quot;);        maptest.put(null, null);        System.out.println(maptest);        System.out.println(maptest.size());  //获取集合的大小        maptest.clear();   //清空集合        maptest.isEmpty();  //判断集合是否为空        maptest.get(2);  //通过键值获取对应值        maptest.put(1, &quot;呵呵哒&quot;);        maptest.put(2, &quot;呵呵哒&quot;);        maptest.put(3, &quot;呵呵哒&quot;);        maptest.put(4, &quot;呵呵哒&quot;);        maptest.put(8, &quot;呵呵哒&quot;);        maptest.put(null, null);        maptest.remove(2);  //通过键值删除对应元素        maptest.containsKey(2);//判断是否包含某个键        maptest.containsValue(&quot;呵呵哒&quot;);//判断是否包含某个值        maptest.keySet();  //获取集合的全部键        maptest.values();  //获取集合的全部值        Map&lt;Integer, String&gt; maptest2 = new HashMap&lt;&gt;();        maptest2.putAll(maptest);//把map1的键全部倒入map2中, 重复的键会覆盖        System.out.println(maptest2);&#39;&#39;&#39;</code></pre><h4 id="map集合遍历方式"><a href="#map集合遍历方式" class="headerlink" title="map集合遍历方式"></a>map集合遍历方式</h4><p>‘’’</p><pre><code>    //遍历map集合    //1. 通过键找值    Set&lt;Integer&gt; integers = maptest.keySet();    for (Integer integer : integers) &#123;        String s = maptest.get(integer);        System.out.println(integer + &quot;-&quot; + s);    &#125;    //2. 通过entrySet方法遍历    Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entries = maptest.entrySet();    for (Map.Entry&lt;Integer, String&gt; entry : entries) &#123;        System.out.println(entry.getKey() +&quot;-&quot;+ entry.getValue() +&quot; &quot;);    &#125;    //3. 用lambda表达式遍历    maptest.forEach((k, v) -&gt; &#123;        System.out.println(k+&quot;-&quot;+v);    &#125;);</code></pre><p>‘’’</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>单例设计模式</title>
      <link href="/2023/10/14/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/10/14/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="单例设计模式创建的方法"><a href="#单例设计模式创建的方法" class="headerlink" title="单例设计模式创建的方法"></a>单例设计模式创建的方法</h1><ol><li><p>饿汉式单例： 拿对象时， 对象已经建立完成。</p><p> ‘’’java</p><pre><code> //2.定义一个类变量， 记住类的对象 private static A a = new A(); //1.私有构造器 private A()&#123; &#125; //3.定义一个类方法， 返回类的对象 public static A getA()&#123;     return a; &#125;</code></pre><p> ‘’’</p></li><li><p>懒汉式单例， 拿对象时， 才开始创建对象。<br> ‘’’java</p><pre><code> //2. 定义一个类变量， 用于存储对象 private static B b; //1. 把构造器私有 private B()&#123; &#125; //3. 定义一个方法， 只有在调用时才创建对象 public static B getInstance()&#123;     if (b == null)&#123;         b = new B();     &#125;     return b; &#125;</code></pre><p> ‘’’</p></li></ol><p>用这种模式创建的对象有且仅有一个</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>API常用类</title>
      <link href="/2023/10/07/API%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
      <url>/2023/10/07/API%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="char字符数组转换成String的一种方式"><a href="#char字符数组转换成String的一种方式" class="headerlink" title="char字符数组转换成String的一种方式"></a>char字符数组转换成String的一种方式</h2><pre><code>    &#39;&#39;&#39;java        char [] arr = new char[]&#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;;        String str = new String(arr);        System.out.println(str);    &#39;&#39;&#39;</code></pre><h2 id="String类常用的方法："><a href="#String类常用的方法：" class="headerlink" title="String类常用的方法："></a>String类常用的方法：</h2><ol><li><p>public int length()            获取字符串的长度返回(就是字符个数</p><pre><code> &#39;&#39;&#39;java     System.out.println(str.length()); &#39;&#39;&#39;</code></pre></li><li><p>public char charAt(int index)        获取某个索引位置处的字符返回   </p><pre><code> &#39;&#39;&#39;java     for (int i = 0; i &lt; str.length(); i++) &#123;                 char ch = str.charAt(i);                 System.out.println(ch);             &#125; &#39;&#39;&#39;</code></pre></li><li><p>public char[] toCharArray():         将当前字符串转换成字符数组返回</p><pre><code> &#39;&#39;&#39;java     char[] chars = str.toCharArray(); &#39;&#39;&#39;</code></pre></li><li><p>public boolean equals(Object anObject)   判断当前字符串与另一个字符串的内容一样，一样返回true</p><pre><code> &#39;&#39;&#39;java     System.out.println(str.equals(str2)); &#39;&#39;&#39;</code></pre></li><li><p>public boolean equalsIgnoreCase(String anotherString)   判断当前字符串与另一个字符串的内容是否一样(忽略大小写)</p><pre><code> &#39;&#39;&#39;java     System.out.println(str.equalsIgnoreCase(str2)); &#39;&#39;&#39;</code></pre></li><li><p>public String substring(int beginIndex, int endIndex)    根据开始和结束索引进行截取，得到新的字符串(包前不包后)</p><pre><code> &#39;&#39;&#39;java     String rar = &quot;学java死路一条&quot;;             System.out.println(rar.substring(0, 5)); &#39;&#39;&#39;</code></pre></li><li><p>public String substring(int beginIndex)      从传入的索引处截取，截取到末尾，得到新的字符串返回</p><pre><code> &#39;&#39;&#39;java     System.out.println(rar.substring(5)); &#39;&#39;&#39;</code></pre></li><li><p>public String replace(CharSequence target，CharSequence replacement)        使用新值，将字符串中的旧值替换，得到新的字符串</p><pre><code> &#39;&#39;&#39;java     System.out.println(rar.replace(&quot;学&quot;, &quot;卷&quot;)); &#39;&#39;&#39;</code></pre></li><li><p>public boolean contains(CharSequence s)          判断字符串中是否包含了某个字符串</p><pre><code> &#39;&#39;&#39;java     System.out.println(rar.contains(&quot;java&quot;)); &#39;&#39;&#39;</code></pre></li><li><p>public boolean startswith(string prefix)            判断字符串是否以某个字符串内容开头，开头返回true，反之</p><pre><code>&#39;&#39;&#39;java    System.out.println(rar.startsWith(&quot;学java&quot;));&#39;&#39;&#39;</code></pre></li><li><p>public String[] split(string regex)              把字符串按照某个字符串内容分割，并返回字符串数组回来    </p><pre><code>&#39;&#39;&#39;java    String string = &quot;呵呵哒，呵呵哒，呵呵哒&quot;;            String[] heheda = string.split(&quot;，&quot;);             for (int i = 0; i &lt; heheda.length; i++) &#123;                System.out.println(heheda[i]);            &#125;&#39;&#39;&#39;</code></pre></li></ol><h2 id="ArrayList类的常用方法"><a href="#ArrayList类的常用方法" class="headerlink" title="ArrayList类的常用方法"></a>ArrayList类的常用方法</h2><p>1. </p><p>add(E e)  将指定元素添加到集合的末尾</p><pre><code>    &#39;&#39;&#39;Java        ArrayList list = new ArrayList();        list.add(&quot;呵呵哒&quot;);        list.add(123);        list.add(1.22);        System.out.println(list);    &#39;&#39;&#39;</code></pre><p>2.<br>add(int i, E e) 往集合中的某个索引位置添加元素</p><pre><code>    &#39;&#39;&#39;Java        list.add(1, &quot;heheda&quot;);        list.add(1,&quot;呵&quot;);        System.out.println(list);    &#39;&#39;&#39;</code></pre><p>3.<br>get(int i)  获取指定索引位置的值</p><pre><code>    &#39;&#39;&#39;java        System.out.println(list.get(1));    &#39;&#39;&#39;</code></pre><p>4.<br>size()  返回集合中的元素数量</p><pre><code>    &#39;&#39;&#39;java        System.out.println(list.size());    &#39;&#39;&#39;</code></pre><p>5.<br>remove(int i)    删除指定索引位置的元素， 并返回删除的值</p><pre><code>    &#39;&#39;&#39;java        System.out.println(list.remove(1));     &#39;&#39;&#39;</code></pre><p>6.<br>remove(Object j)   删除指定的元素， 并返回删除是否成功</p><pre><code>    &#39;&#39;&#39;java        System.out.println(list.remove(&quot;呵&quot;));  //默认删除第一个出现的指定元素    &#39;&#39;&#39;</code></pre><p>7.<br>set(int i, Element e)  替换指定索引位置的元素, 并返回被修改的值</p><pre><code>    &#39;&#39;&#39;java        System.out.println(list.set(1, &quot;呵呵哒&quot;));    &#39;&#39;&#39;</code></pre><h1 id="包装类的一些方法"><a href="#包装类的一些方法" class="headerlink" title="包装类的一些方法"></a>包装类的一些方法</h1><h4 id="Objects类的常用方法"><a href="#Objects类的常用方法" class="headerlink" title="Objects类的常用方法"></a>Objects类的常用方法</h4><p>equals(Object a, Object b)  判断两个对象内容是否相等</p><pre><code>    &#39;&#39;&#39;java        String str = &quot;heheda&quot;;        String str2 = &quot;heheda&quot;;        System.out.println(str.equals(str2));  //原来这种方法有安全问题， 可能报空指针异常        System.out.println(Objects.equals(str, str2));    &#39;&#39;&#39;</code></pre><p>isNull(Object obj)  判断一个对象是否是null </p><pre><code>    &#39;&#39;&#39;java            String str = null;            String str2 = &quot;heheda&quot;;            // System.out.println(str.equals(str2));            System.out.println(Objects.equals(str, str2));            System.out.println(Objects.isNull(str));            System.out.println(Objects.isNull(str2));    &#39;&#39;&#39;</code></pre><p>nonNull(Object obj) 判断一个对象是否不是null</p><pre><code>    &#39;&#39;&#39;java        System.out.println(Objects.nonNull(str2));    &#39;&#39;&#39;</code></pre><h4 id="Interger类的常用方法-以此类推其他基本数据类型包装类"><a href="#Interger类的常用方法-以此类推其他基本数据类型包装类" class="headerlink" title="Interger类的常用方法, 以此类推其他基本数据类型包装类"></a>Interger类的常用方法, 以此类推其他基本数据类型包装类</h4><p>toString(int i)  </p><pre><code>    &#39;&#39;&#39;        Integer a = 123;//自动装箱        System.out.println(a.toString());        String str = Integer.toString(a);        System.out.println(str);        //自动拆箱        int a2 = a;    &#39;&#39;&#39;</code></pre><p>可以把基本数据类型转换成字符串数据类型</p><p>toString(double d)<br>toString()</p><pre><code>    &#39;&#39;&#39;        int a2 = a;        Integer.toString(a2);        String sttr = a.toString();    &#39;&#39;&#39;</code></pre><p>可以把字符串数值转换成对应数值的数据类型</p><p>parseInt(String str)<br>valueOf(String str)</p><pre><code>    &#39;&#39;&#39;        int i = Integer.parseInt(sttr);        int j = Integer.valueOf(sttr);    &#39;&#39;&#39;</code></pre><h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><p>append(任意类型)   &#x2F;&#x2F;添加各种类型的数据</p><pre><code>&#39;&#39;&#39;        StringBuilder stringBuilder = new StringBuilder(&quot;呵呵哒&quot;);        stringBuilder.append(1);        stringBuilder.append(&quot;呵呵哒&quot;);        stringBuilder.append(true);        System.out.println(stringBuilder);        //允许连续拼接        stringBuilder.append(&quot;呵呵哒&quot;).append(&quot;呵呵哒&quot;).append(111);&#39;&#39;&#39;</code></pre><p>reverse（）       &#x2F;&#x2F;将对象的内容反转</p><pre><code>&#39;&#39;&#39;    //反转操作    stringBuilder.reverse();    System.out.println(stringBuilder);&#39;&#39;&#39;</code></pre><p>length()       &#x2F;&#x2F;返回对象内容长度</p><pre><code>&#39;&#39;&#39;    stringBuilder.length();&#39;&#39;&#39;</code></pre><p>toString()            &#x2F;&#x2F;转换为String并返回内容</p><pre><code>&#39;&#39;&#39;    stringBuilder.toString();    &#39;&#39;&#39;</code></pre><p>###StringJoiner类 </p><p>public StringJoiner(间隔符)</p><pre><code>&#39;&#39;&#39;        StringJoiner str = new StringJoiner(&quot;, &quot;);        str.add(&quot;呵呵哒&quot;);        str.add(&quot;呵呵哒&quot;);        str.add(&quot;呵呵哒&quot;);        str.add(&quot;呵呵哒&quot;);        System.out.println(str);&#39;&#39;&#39;</code></pre><p>public StringJoiner(间隔符， 开始符号， 结束符号)</p><pre><code>&#39;&#39;&#39;    StringJoiner str2 = new StringJoiner(&quot;, &quot;,&quot;[&quot;,&quot;]&quot;);    str2.add(&quot;呵呵哒&quot;);    str2.add(&quot;呵呵哒&quot;);    str2.add(&quot;呵呵哒&quot;);    str2.add(&quot;呵呵哒&quot;);    System.out.println(str2);&#39;&#39;&#39;</code></pre><h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><p>System.exits()<br>Ststem.currentTimeMillis() 获取1970 1-1 0:0：0开始走到此刻的毫秒值<br>        ‘’’<br>                &#x2F;&#x2F;        System.exit(0);&#x2F;&#x2F;终止java虚拟机</p><pre><code>            long time1 = System.currentTimeMillis();            for (int i = 0; i &lt; 1000000; i++) &#123;                System.out.println(i);            &#125;            long time2 = System.currentTimeMillis();            String time = (time2 - time1)/ 1000.0 +&quot;s&quot;;            System.out.println(time);    &#39;&#39;&#39;</code></pre><h3 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h3><p>exit()  终止虚拟机操作， 一般不用</p><pre><code>    &#39;&#39;&#39;        // Runtime.getRuntime().exit(0);  //终止虚拟机    &#39;&#39;&#39;</code></pre><p>availableProcessors()  返回虚拟机能调用的处理器数量</p><pre><code>    &#39;&#39;&#39;        System.out.println(Runtime.getRuntime().availableProcessors()); //返回虚拟机能使用的处理器数量    &#39;&#39;&#39;</code></pre><p>totalMemory()   返回虚拟机中内存总量， long类型 字节</p><pre><code>    &#39;&#39;&#39;        System.out.println(Runtime.getRuntime().totalMemory());  //返回虚拟机中内存总量        System.out.println(Runtime.getRuntime().totalMemory() / 1024.0 / 1024.0 + &quot;MB&quot;);    &#39;&#39;&#39;</code></pre><p>freeMemory() 返回虚拟机中空闲的内存数量</p><pre><code>    &#39;&#39;&#39;        System.out.println(Runtime.getRuntime().freeMemory()/ 1024.0 / 1024.0 + &quot;MB&quot;);//返回虚拟机中空闲的内存数量    &#39;&#39;&#39;</code></pre><p>exec()  根据路径启动某个程序， 需要管理员权限</p><pre><code>    &#39;&#39;&#39;        Runtime.getRuntime().exec(&quot;D:\\Star Rail\\launcher.exe&quot;);  //启动 某个程序， idea需要管理员权限    &#39;&#39;&#39;</code></pre><p>Process.destroy();   &#x2F;&#x2F;用于结束通过exec启动的程序</p><pre><code>    &#39;&#39;&#39;        Process p = Runtime.getRuntime().exec(&quot;D:\\Star Rail\\launcher.exe&quot;);  //启动 某个程序， idea需要管理员权限, 返回Process类， 即软件对象        Thread.sleep(5000);  //让程序在此等待5s        p.destroy();  //结束这个软件    &#39;&#39;&#39;</code></pre><h3 id="BigDecimal类，-在java中-浮点类数据计算可能出现精度问题，-用BigDecimal类可以解决"><a href="#BigDecimal类，-在java中-浮点类数据计算可能出现精度问题，-用BigDecimal类可以解决" class="headerlink" title="BigDecimal类， 在java中 浮点类数据计算可能出现精度问题， 用BigDecimal类可以解决"></a>BigDecimal类， 在java中 浮点类数据计算可能出现精度问题， 用BigDecimal类可以解决</h3><pre><code>&#39;&#39;&#39;        BigDecimal a = BigDecimal.valueOf(0.1);        BigDecimal b = BigDecimal.valueOf(0.2);        System.out.println(a.add(b)); //加        System.out.println(a.subtract(b));  //减        System.out.println(a.multiply(b));  // 乘        System.out.println(a.divide(b));   //除        System.out.println(b.divide(a, 3, RoundingMode.HALF_UP));   //除数  精确几位， 舍入模式&#39;&#39;&#39;</code></pre><h3 id="Date类和Simpledateformat类"><a href="#Date类和Simpledateformat类" class="headerlink" title="Date类和Simpledateformat类"></a>Date类和Simpledateformat类</h3><pre><code>&#39;&#39;&#39;        Date d = new Date();        System.out.println(d);        long time = d.getTime();        System.out.println(time);        SimpleDateFormat s = new SimpleDateFormat(&quot;yyyy-MM-dd HH时mm分ss秒 EEE a&quot;);        System.out.println(s.format(time));        System.out.println(s.format(d));        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;);        System.out.println(simpleDateFormat.format(d));        simpleDateFormat.format(time);        String dtime = &quot;2022-12-12 12:11&quot;;        SimpleDateFormat s2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);        System.out.println(s2.parse(dtime));&#39;&#39;&#39;</code></pre><h3 id="Calander类"><a href="#Calander类" class="headerlink" title="Calander类"></a>Calander类</h3><pre><code>&#39;&#39;&#39;        Calendar ca = Calendar.getInstance();        System.out.println(ca);        int i = ca.get(Calendar.MONTH);             System.out.println(i);        ca.set(Calendar.MONTH, 10);        System.out.println(ca);        ca.add(Calendar.DAY_OF_YEAR, 10);        ca.add(Calendar.DAY_OF_YEAR, -10);        System.out.println(ca);&#39;&#39;&#39;</code></pre><h2 id="JDK8新增的时间日期类"><a href="#JDK8新增的时间日期类" class="headerlink" title="JDK8新增的时间日期类"></a>JDK8新增的时间日期类</h2><p>LocalDate :代表本地日期（年、月、日、星期）<br>LocalTime： 代表本地时间（时、分、秒、纳秒）<br>LocalDateTime：代表本地日期时间：（年、月、日、星期、时、分、秒、纳秒） &#x2F;&#x2F;用的最多</p><p>以LocalDate类为例：</p><p>‘’’<br>        LocalDate localDate &#x3D; LocalDate.now();<br>        System.out.println(localDate);<br>        System.out.println(localDate.getYear());<br>        System.out.println(localDate.getMonth());<br>        System.out.println(localDate.getDayOfMonth());<br>        System.out.println(localDate.getDayOfWeek().getValue());</p><pre><code>    LocalDate localDate1 = localDate.withYear(2099); //返回新的localdate类型， 原来的对象数据不变    System.out.println(localDate1);    System.out.println(localDate);    LocalDate localDate2 = localDate.withMonth(12); //返回新的localdate类型， 原来的对象数据不变    System.out.println(localDate2);    localDate.plusYears(2);  //加两年， 返回新的对象    localDate.minusYears(2); //减两年， 返回新的对象    LocalDate.of(2022, 12, 10);//获取指定时间对象， 返回新的对象    localDate.equals(localDate1); //判断日期对象是否相等    localDate.isAfter(localDate1); //判断日期是否在指定对象后面    localDate.isBefore(localDate1); //判断日期是否在指定对象后面</code></pre><p>‘’’<br>剩下的两类以此类推， 方法名是一样的<br>其中， LocalDateTime可以分开也可合并</p><p>‘’’<br>        LocalDate l1 &#x3D; localDateTime.toLocalDate(); &#x2F;&#x2F;分开<br>        LocalTime l2 &#x3D; localDateTime.toLocalTime();</p><pre><code>    LocalDateTime of = LocalDateTime.of(l1, l2);  //合并</code></pre><p>‘’’</p><h4 id="ZonId类和Instant类"><a href="#ZonId类和Instant类" class="headerlink" title="ZonId类和Instant类"></a>ZonId类和Instant类</h4><p>ZonId主要获取时区对象<br>Instant用以替代原来的DAte对象</p><p>‘’’</p><pre><code>    ZoneId z = ZoneId.systemDefault();    System.out.println(z.getId());    System.out.println(z);    System.out.println(ZoneId.getAvailableZoneIds());    ZoneId of = ZoneId.of(&quot;Asia/Aden&quot;);    System.out.println(of);    System.out.println(ZonedDateTime.now(of));    System.out.println(ZonedDateTime.now(Clock.systemUTC())); //世界标准时间    Instant i = Instant.now();    System.out.println(i.getEpochSecond());</code></pre><p>‘’’</p><h4 id="Period类和Duration类"><a href="#Period类和Duration类" class="headerlink" title="Period类和Duration类"></a>Period类和Duration类</h4><p>Period类用于计算两个localDAte类相差的年月日<br>Duration类用于计算两个时间对象相差的天、小时、分、秒、纳秒<br>用法同上或见API文档</p><p>‘’’<br>        LocalDate localDateTime1 &#x3D; LocalDate.of(2022, 11, 11);<br>        LocalDate localDateTime2 &#x3D; LocalDate.of(2023, 12, 12);</p><pre><code>    Period p = Period.between(localDateTime1, localDateTime2);    System.out.println(p.getYears());    System.out.println(p.getMonths());    LocalDateTime loc1 = LocalDateTime.of(2022, 2, 11, 12, 24, 48);    LocalDateTime loc2 = LocalDateTime.of(2022, 12, 12, 3, 48, 59);    Duration duration = Duration.between(loc1, loc2);    System.out.println(duration.toDays());</code></pre><p>‘’’</p><h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><p>‘’’<br>        LocalDate localDateTime1 &#x3D; LocalDate.of(2022, 11, 11);<br>        LocalDate localDateTime2 &#x3D; LocalDate.of(2023, 12, 12);</p><pre><code>    Period p = Period.between(localDateTime1, localDateTime2);    System.out.println(p.getYears());    System.out.println(p.getMonths());    LocalDateTime loc1 = LocalDateTime.of(2022, 2, 11, 12, 24, 48);    LocalDateTime loc2 = LocalDateTime.of(2022, 12, 12, 3, 48, 59);    Duration duration = Duration.between(loc1, loc2);    System.out.println(duration.toDays());    </code></pre><p>‘’’</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于主题配置位置的说明</title>
      <link href="/2023/09/22/%E5%85%B3%E4%BA%8E%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%AF%B4%E6%98%8E/"/>
      <url>/2023/09/22/%E5%85%B3%E4%BA%8E%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p>butterfly主题配置的文件处于Myblog\node_modules\hexo-theme-butterfly 中</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的试用文章</title>
      <link href="/2023/09/20/%E6%88%91%E7%9A%84%E8%AF%95%E7%94%A8%E6%96%87%E7%AB%A0/"/>
      <url>/2023/09/20/%E6%88%91%E7%9A%84%E8%AF%95%E7%94%A8%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落示例段落</p><p>示例段落示例段落示例段落</p><p>示例段落示例段落示例段落</p><p>示例段落示例段落示例段落</p><p><em>斜体文本</em></p><p><strong>粗体文本</strong></p><p><em><strong>粗斜体文本</strong></em></p><p>这是一个分隔符</p><hr><hr><p>* </p><p>- </p><hr><hr><hr><p><del>这是删除</del></p><p>这是无序列表</p><p>* </p><ul><li></li><li></li></ul><ul><li>一</li><li>二</li><li>三</li></ul><ul><li></li><li></li><li></li></ul><p>这是有序列表</p><p>1.<br>2.<br>3.  </p><ol><li>第一项<ul><li>子列表1</li><li>子列表2</li><li>子列表3</li></ul></li><li>第二项：<ul><li>子列表1</li><li>子列表2</li><li>子列表3</li></ul></li></ol><p>引用</p><blockquote><p>引用的内容</p><p>这是内容</p></blockquote><blockquote><p>第二段引用 的内容</p><p>这是内容</p></blockquote><p>区块嵌套</p><blockquote><p>引用</p><blockquote><p>引用</p></blockquote></blockquote><blockquote><blockquote><blockquote></blockquote><blockquote><blockquote></blockquote></blockquote></blockquote></blockquote><p>‘’’c</p><p>#include &lt;stdio.h&gt;</p><p>int main()</p><p>{</p><pre><code> printf(&quot;Hello World !&quot;);</code></pre><p>​return 0;</p><p>}</p><p>‘’’</p><p><a href="www.moussemou.cn">链接名称</a></p><p>&lt;<a href="http://www.moussemou.cn>">www.moussemou.cn&gt;</a></p><p><a href="https://www.msn.cn/zh-cn/news/other/%E8%B5%B5%E6%98%8E-%E8%8D%A3%E8%80%80%E5%9B%9E%E5%BD%92%E5%8D%8E%E4%B8%BA%E7%BB%9D%E6%97%A0%E5%8F%AF%E8%83%BD/ar-AA1gWELc?ocid=msedgntp&pc=EDGENTP&cvid=563da8064b7a40fc84fa3aff76c9c7c2&ei=6">图片描述</a></p><p>表格</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/09/19/hello-world/"/>
      <url>/2023/09/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
